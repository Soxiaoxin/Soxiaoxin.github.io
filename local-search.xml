<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Web安全</title>
    <link href="/2021/06/27/Web%E5%AE%89%E5%85%A8/"/>
    <url>/2021/06/27/Web%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>Cross-Site Scripting（跨站脚本攻击），是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在浏览器运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息，如Cookie、SessionID等，进而危害数据安全。</p><p>任何可以输入的地方，都可能造成XSS攻击，包括URL。</p><p>常见的XSS目的：盗取cookie、投放广告、监听用户行为、修改DOM结构获取用户信息。</p><h4 id="XSS的分类"><a href="#XSS的分类" class="headerlink" title="XSS的分类"></a>XSS的分类</h4><p>根据攻击来源，可以分为3类：存储型、反射型、DOM型。</p><h5 id="存储型XSS（持久性）"><a href="#存储型XSS（持久性）" class="headerlink" title="存储型XSS（持久性）"></a>存储型XSS（持久性）</h5><ol><li>攻击者将恶意代码提交到<strong>目标网站的数据库</strong>中。</li><li>当用户打开网站，网站服务端将恶意代码调出，拼接在HTML中返回给浏览器。</li><li>浏览器解析执行，混在其中的恶意脚本也被执行。</li><li>该恶意脚本窃取用户数据发送到攻击者的网站，或冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>常见于带有用户数据保存的网站功能。比如攻击者在网站上提交一篇有恶意脚本的文章，被存到了数据库，当用户访问这个文章，浏览器解析到这段恶意脚本，就会执行。</p><h5 id="反射型XSS（非持久性）"><a href="#反射型XSS（非持久性）" class="headerlink" title="反射型XSS（非持久性）"></a>反射型XSS（非持久性）</h5><ol><li>攻击者构造初特殊的URL，其中包含恶意代码。</li><li><strong>诱导用户打开带有恶意代码的URL</strong>，网站服务器端不对这个url参数过滤处理，简单的“反射”给浏览器。</li><li>浏览器解析执行，混在其中的恶意脚本也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>它和存储型XSS的区别是：存储型XSS的恶意代码保存在数据库中，而反射型XSS保存在URL中。</p><p>常见于通过URL传参的功能，如网站搜索、跳转、QQ邮件中的一些恶意链接等。</p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><ol><li>基于浏览器解析DOM导致的漏洞，并不依赖于服务器</li><li>用户点击一个带有恶意脚本的URL</li><li>浏览器在DOM解析的时候直接使用了恶意数据</li><li>导致用户受到攻击</li></ol><p>DOM型XSS和前两种的区别：DOM型XSS取出和执行恶意代码由浏览器完成，属于前端JS自身安全漏洞，而前两种是服务器的安全漏洞。防范DOM型XSS完全是前端的责任。</p><p>比如说：前端把某个元素的.innerHTML设置为一个输入框的相关数据，当恶意攻击者在输入框输入恶意脚本，这个脚本会被执行。</p><h4 id="XSS-Payload"><a href="#XSS-Payload" class="headerlink" title="XSS Payload"></a>XSS Payload</h4><p>有效的XSS攻击，包括：</p><ul><li>窃取用户的Cookie (document.cookie)</li><li>识别用户的浏览器 (navigator.userAgent)</li><li>伪造请求</li><li>钓鱼网站 (在页面中注入钓鱼网站链接，诱导用户点击)</li></ul><h4 id="常见XSS防范方法"><a href="#常见XSS防范方法" class="headerlink" title="常见XSS防范方法"></a>常见XSS防范方法</h4><ul><li>设置httpOnly：这样js脚本就无法获取cookie的信息了。</li><li>设置黑名单，对不安全的输入进行过滤和转码，把<script>标签、javascript等字符过滤掉</li><li>设置白名单，只有符合相应格式的输入才能通过</li><li>利用CSP，明确表示哪些外部资源是可以加载和执行的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;script-src &#x27;self&#x27;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者设置http头部字段：Content-Security-Policy</p><ul><li><p>X-XSS-Protection</p><p>在http的响应头中设置该字段：</p><p>0：禁用XSS过滤</p><p>1：启用XSS过滤（默认），当检测到XSS攻击，会删除页面中不安全的部分</p><p>1;mode=block：当检测到XSS攻击，会阻止页面的加载</p><p>1; report=<report-url>：当检测到攻击，会清除页面并且使用CSP的功能发送违规报告。</p></li></ul><h4 id="预防DOM型XSS攻击"><a href="#预防DOM型XSS攻击" class="headerlink" title="预防DOM型XSS攻击"></a>预防DOM型XSS攻击</h4><ul><li>小心使用<code>.innerHTML</code> <code>.outerHTML</code> <code>document.write()</code>，不要把不可信数据作为HTML插到页面上，尽量使用<code>.textContent</code> <code>.setAttribute()</code>。</li><li>在Vue和React中，不要使用v-html、dangerouslySetInnerHTML，这样就在前端render阶段避免了XSS隐患。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ul><h2 id="CSRF（Cross-Site-request-forgery）"><a href="#CSRF（Cross-Site-request-forgery）" class="headerlink" title="CSRF（Cross-Site request forgery）"></a>CSRF（Cross-Site request forgery）</h2><p>跨站点请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意操作的攻击。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h4 id="常见CSRF类型"><a href="#常见CSRF类型" class="headerlink" title="常见CSRF类型"></a>常见CSRF类型</h4><h5 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> &gt;</span> <br></code></pre></td></tr></table></figure><p>当用户打开有这张图片的页面，浏览器就会自动向bank这个网站发起HTTP请求。</p><h5 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h5><p>使用一个自动提交的表单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://bank.example/withdraw&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaoming&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;amount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"> <span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].submit(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>访问该页面后，表单自动提交，相当于模拟用户进行了一次POST操作。</p><h5 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="hljs-attribute">taget</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;<br> 重磅消息！！<br> &lt;a/&gt;<br></code></pre></td></tr></table></figure><h4 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h4><ul><li>攻击一般发起在第三方网站，被攻击的网站无法阻止发生</li><li>利用了受害者在被攻击网站的登陆凭证，冒充受害者提交操作</li><li>跨站请求可以用各种方式：图片URL、超链接、Form提交等。</li></ul><h4 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h4><ul><li>有时候，CSRF是由XSS实现的（蠕虫）     。</li><li>本质上说，XSS是代码注入的问题，CSRF是HTTP的问题。XSS是因为内容上没有过滤导致浏览器将攻击者的代码执行。CSRF则是因为浏览器发送HTTP的时候自动带上Cookie，而一般网站的session都存在cookie里。</li></ul><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><ul><li><p>防止用户不知情的情况下盗用了用户的身份</p><p>验证码：强制用户必须与应用进行交互，才达成最终请求。</p><p>用户体验不好</p></li><li><p>防止跨站请求</p><p>Refer check：通过request header的referer字段，查看请求来自哪个源</p><p>不可靠，依然可能被篡改</p></li><li><p>防止参数伪造</p><p>token（常用）：前后端协商一个token加密的算法，当前端发起请求的时候，带上token，后端收到请求后，用同样的方式算出用户对应的token，如果一致，才通过验证。</p></li><li><p>sameSite：在服务器通过set-cookie返回响应的时候，可以设置samesite属性的值为strict</p></li></ul><h3 id="samesite"><a href="#samesite" class="headerlink" title="samesite"></a>samesite</h3><p>strict：完全禁止发送第三方Cookie，只有当前URL和请求目标一致才带上Cookie</p><p>lax：允许发送Get请求的第三方Cookie</p><p>none：允许发送所有Cookie，但cookie要用secure属性，否则无效</p><p>第一方Cookie：用户访问的域创建的Cookie。</p><p>第三方Cookie：建立在别的域名下的Cookie，比如广告网络商是最常见的第三方Cookie来源。</p><h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><p>通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。</p><p>就好比一家餐厅原本能同时容纳30个人，但有一天，一个流氓带着300个人进了餐厅，占着位置但是却不点餐，导致正常的顾客页无法光顾，餐厅瘫痪了。</p><h4 id="DDOS防范"><a href="#DDOS防范" class="headerlink" title="DDOS防范"></a>DDOS防范</h4><ul><li>验证码：降低用户体验</li><li>限制请求频率：通过一些标识（IP或Cookie）定位客户端，限制一个客户端请求的频率</li><li>扩容加带宽：适合双十一活动或12306抢车票等场景</li></ul><h2 id="网页劫持"><a href="#网页劫持" class="headerlink" title="网页劫持"></a>网页劫持</h2><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>解析域名时，服务提供商可能会对IP地址劫持，返回一个错误的IP地址。</p><h4 id="HTTP劫持"><a href="#HTTP劫持" class="headerlink" title="HTTP劫持"></a>HTTP劫持</h4><p>DNS劫持一般会替换整个网页，而http劫持，利用了http协议明文传输的特点，篡改了返回的html内容。</p><p>常见的场景是在页面加一个小窗，可能投放广告。</p><p>这是由于信息没有加密而造成的。可以使用HTTPS解决。</p><h4 id="路由劫持"><a href="#路由劫持" class="headerlink" title="路由劫持"></a>路由劫持</h4><p>比如：小米路由器，把404之类的页面换成自己的页面。</p><h4 id="软件劫持"><a href="#软件劫持" class="headerlink" title="软件劫持"></a>软件劫持</h4><p>使用一些软件来清除广告，但这会管控全局流量，电脑的所有网络流量都会经过这个软件，所以进行劫持也是很简单的事情。</p>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端模块化</title>
    <link href="/2021/06/13/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/06/13/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么前端开发需要模块化？"><a href="#为什么前端开发需要模块化？" class="headerlink" title="为什么前端开发需要模块化？"></a>为什么前端开发需要模块化？</h2><p>在讨论模块化之前，我们先了解一下以前的代码是怎么组织的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 许多html代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&#x27;./index.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一开始，我们可能会将所有的JS代码写在一个index.js文件里，然后通过script标签引入。后来，随着业务逐渐复杂，index.js文件变得庞大，也变得难以维护。所以我们考虑将代码按照功能模块，拆分到不同的文件里，然后引入多个js文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./a.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./b.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;./c.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过这样的拆分，我们各个文件的代码量变少了，看起来确实会更清晰，但是也会带来几个问题：</p><ul><li><p>命名冲突和变量污染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// index.html</span><br>&lt;script src=<span class="hljs-string">&quot;./a.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script src=<span class="hljs-string">&quot;./b.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  <span class="hljs-built_in">console</span>.log(a, b); <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>假设有两个功能模块a和b，分别拆分到a.js和b.js中，上面的代码打印出来的是<code>1 2</code>，其实没有什么问题，但如果有一天，一个新接手的程序员，在b.js中又定义了一个变量a。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这时候，控制台打印的代码变成：<code>3 2</code>。由于a和b都是定义到了全局作用域，所用两个模块的变量命名有了冲突。我们可以通过修改变量名来规避，但这是治标不治本的，因为他们没有自己的作用域，所以我们依然可以在b模块中，修改a模块的变量，可能会造成一些bug。</p></li><li><p>资源或模块之间的依赖</p><p>如上面的代码片段，在html中添加了很多script标签来一个个引入资源，首先可能会造成很多请求，导致页面卡顿。</p><p>更重要的是，如果资源之间有依赖关系，还要按照依赖关系从上到下排序。如果引入了defer或async属性，逻辑将会变得更加复杂，难以维护。</p></li></ul><h2 id="实现模块化"><a href="#实现模块化" class="headerlink" title="实现模块化"></a>实现模块化</h2><p>那么我们要如何解决这两个问题呢？</p><h3 id="解决命名冲突和变量污染"><a href="#解决命名冲突和变量污染" class="headerlink" title="解决命名冲突和变量污染"></a>解决命名冲突和变量污染</h3><p>为了避免命名冲突和变量污染，我们想到为每一个模块创建一个私有的作用域，避免命名冲突，模块外只能访问被暴露的一些变量，避免变量污染。</p><p>由于在函数内部可以形成一个局部作用域，所以我们可以将模块的代码包裹到一个函数中，而且考虑到我们往往只需要调用一次这个函数，所以可以使用立即执行函数表达式（IIFE）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> moduleA = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    foo,<br>  &#125;;<br>&#125;)();<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> moduleB = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a, b);<br>  &#125;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    foo,<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  moduleA.foo(); <span class="hljs-comment">// 1</span></span><br><span class="javascript">  moduleB.foo(); <span class="hljs-comment">// 3 2</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个时候，尽管两个module都有变量a和方法foo，但是他们都在各自的作用域里，不会造成命名冲突，而且moduleB也无法修改moduleA的变量，不会造成变量污染。</p><h3 id="解决模块间的依赖"><a href="#解决模块间的依赖" class="headerlink" title="解决模块间的依赖"></a>解决模块间的依赖</h3><p>我们的一个模块，可以会依赖另外一个模块，所以在html中，我们要注意按顺序引入，比如有这样一个依赖图：</p><p><img src="/2021/06/13/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/%E4%BE%9D%E8%B5%961.png" alt="依赖1"></p><p>通过拓扑排序，我们的引入顺序可能是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./d.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./c.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时候，如果新添加一个moduleE，那么我们要重新分析依赖，把moduleE的引入放在合适的位置。随着业务的发展，每次添加一个module，都要重新分析的话，不仅笨重，而且给维护也带来了一定的困难。</p><p>所以，手动管理依赖终究不是一个好办法。</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><p>虽然上面我们讨论了模块化的实现，但还是存在两个问题：</p><ul><li>模块化实现方式不统一</li><li>手动维护模块依赖困难</li></ul><p>为了解决这两个问题，开发人员们提出了模块化规范，也就是统一定义模块的方法，以及解放手动维护依赖。</p><p>目前主流的三种模块化规范分别是：</p><ul><li>CommonJS</li><li>AMD</li><li>CMD</li></ul><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>这个规范在Node.js中被广泛使用，每个文件就是一个模块。有四个关键的环境变量：</p><ul><li><code>module</code>：每个模块内部都有一个这样的变量，表示当前模块</li><li><code>exports</code>：module的一个属性，表示对外暴露的接口</li><li><code>global</code>：表示全局环境（Node）</li><li><code>require</code>：同步加载某个模块的exports属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> addA = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + value;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  a,<br>  addA<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">const</span> &#123; a, addA &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(addA(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>这个规范中，以同步的方式加载模块。因为在服务端，模块文件都存在本地磁盘，读取速度快，这这样做不会有问题，但如果在浏览器端，由于网络原因，应该使用异步加载，提前编译打包好。</p><p>CommonJS模块的加载机制是，加载被输出的值的拷贝，也就是说，一旦这个值输出了，模块内部对这个值的修改，不会影响被输出的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> addA = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  a++;<br>&#125;<br><span class="hljs-keyword">var</span> getA = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  a,<br>  addA,<br>  getA<br>&#125;<br><br><span class="hljs-comment">// b.js</span><br><span class="hljs-keyword">var</span> &#123; a, addA, getA &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br>addA();<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(getA()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>从上面一段代码可以看到，调用了addA方法，虽然a.js内部的a值已经变成了2，但是这不会影响到b.js模块引入的a值，因因为a是原始类型的值，载入时被缓存起来了。</p><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>一般在浏览器环境下采用，异步加载模块，所有依赖这个模块的语句，都会被定义在一个回调函数中。</p><p>主要命令：<code>define(id?, dependency?, factory)</code>、<code>require(modules, callback)</code></p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义没有依赖的模块A</span><br>define(<span class="hljs-string">&#x27;moduleA&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>  <span class="hljs-comment">//...</span><br>&#125;);<br><span class="hljs-comment">// 定义依赖模块A、B、C的模块D</span><br>define(<span class="hljs-string">&#x27;moduleD&#x27;</span>, [<span class="hljs-string">&#x27;moduleA&#x27;</span>, <span class="hljs-string">&#x27;moduleB&#x27;</span>, <span class="hljs-string">&#x27;moduleC&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>  <span class="hljs-comment">// 在最前面声明并初始化了依赖的所有模块</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>)&#123;<br>    <span class="hljs-comment">// 即便没用到b，但b还是初始化且执行了</span><br>    b.dosomething();<br>  &#125;<br>  <span class="hljs-comment">// 通过return方法暴露接口</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 加载模块</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;moduleA&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;<br><span class="hljs-comment">// ...  </span><br>&#125;);<br></code></pre></td></tr></table></figure><p>实现这个规范，需要模块加载器require.js，所以引入模块之前，我们要先引入require.js文件，新建main.js，作为入口文件，也可以使用require.config()定义模块依赖的配置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./require.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  a.say(); <span class="hljs-comment">// b a</span><br>&#125;);<br><br><span class="hljs-comment">// a.js</span><br>define(<span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;<br>    b.say();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    say<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// b.js</span><br>define(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>)</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b&#x27;</span>);<br>  &#125;<br>  <span class="hljs-built_in">exports</span>.say = say;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>另一种js模块化方案，与AMD类似。AMD推崇依赖前置，提前执行。而CMD推崇依赖就近、延迟执行。在使用某个模块时，需要显式声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">define([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>); <span class="hljs-comment">// 使用时需声明</span><br>  a.doSomething();<br>&#125;)<br></code></pre></td></tr></table></figure><p>要使用这个规范，需要引入模块加载器SeaJS，用法类似requireJS，只是需要在回调函数里显式的使用require引入模块，在这里暂时不赘述。</p><p>随着时代的发展，Web相关的标准不断更新，ES6也引入了新的模块规范，requireJS和SeaJS虽然能用，但是也过时了，人们对它们不再像从前一样依赖。</p><h2 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h2><p>无论是CommonJS还是AMD，都是在运行的时候，才能确定模块的依赖关系和输入输出，而ES6的模块设计，则是追求尽量静态化。在模块中你使用 import 和 export 关键字来导入或导出模块中的东西。</p><p>ES6 module有几个特点：</p><ul><li>自动开启严格模式</li><li>一个 JS 文件就代表一个 JS 模块</li><li>每个模块就是一个单例，只会加载一次</li></ul><p>和CommonJS相比：</p><ul><li><p>commonJS输出的是值的拷贝，ES6输出的是值的引用</p></li><li><p>commonJS是运行时加载，ES6是编译时输出接口。commonJS模块就是对象，在输入时加载整个模块，再从这个对象上读方法。而ES6允许import指定加载某个输出值。</p><p>因为CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>注意，默认导出有两种方法，它们有微妙的区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一种写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br><br><span class="hljs-comment">// 第二种写法</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">export</span> &#123; a <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;;<br><br></code></pre></td></tr></table></figure><ul><li>第一种写法中，export default绑定的是a这个表达式，而不是标识符。因此，当在export default后更新a值，并不会反映到导出的值中。</li><li>而第二种写法，导出绑定了a这个标识符，所以a的修改会影响到导出侧的值。</li></ul><p>实际采用哪一种写法，可以根据这个导出后续是否需要更新来选择。无论如何，我们最好通过代码注释，来解释我们的意图。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了解决命名冲突、变量污染以及模块依赖管理的问题，前端引入了模块化的规范。</p><p>其中，CommonJS规范是同步加载，适合服务器端使用。</p><p>在浏览器端，我们要使用异步的模块化规范，早期提出了AMD和CMD规范.</p><p>随着时代的发展，ES6 module参考CommonJS和AMD，标准化了模块的加载和解析方式，实现起来也更加简单，提供了更加简洁的语法，成为了浏览器和服务器端通用的一种规范。</p><p><img src="/2021/06/13/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96.png" alt="总结"></p><p>参考资料：<br><a href="https://juejin.cn/post/6844903744518389768#heading-49">前端模块化详解</a></p><p><a href="https://ke.qq.com/classroom/index.html#course_id=327150&term_id=100388238&ch_id=498625&vch_id=274&section_id=1077&task_id=2639536576593390">NEXT学位课程</a></p><p>《你不知道的JavaScript》（下卷）</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/06/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/06/08/%E3%80%90%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p></blockquote><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>转义</td></tr><tr><td>匹配位置：</td><td></td></tr><tr><td>^</td><td>匹配输入的开始</td></tr><tr><td>$</td><td>匹配输入的结束</td></tr><tr><td>\b</td><td>匹配单词的开始或结束（所谓单词的开始和结束，就是\b前后不同时是\w）</td></tr><tr><td>x(?=y)</td><td>正向前瞻，仅匹配后面紧跟着y的x</td></tr><tr><td>x(?!y)</td><td>负向前瞻，仅匹配后面不跟着y的x</td></tr><tr><td>匹配字符</td><td></td></tr><tr><td>\w</td><td>字母、数字、下划线</td></tr><tr><td>\d</td><td>数字</td></tr><tr><td>\s</td><td>空白字符，包括空格、制表符、换页符和换行符</td></tr><tr><td>[xyz]</td><td>匹配[]中的任意字符</td></tr><tr><td>x|y</td><td>匹配x或y</td></tr><tr><td>.</td><td>默认匹配除换行符之外的任何单个字符</td></tr><tr><td>量词</td><td></td></tr><tr><td>*</td><td>匹配前一个表达式0次或多次</td></tr><tr><td>?</td><td>匹配前一个表达式0次或1次<br />正则默认是贪婪匹配，也就是匹配尽量多的字符<br />在量词后的?表示当前匹配是惰性匹配</td></tr><tr><td>+</td><td>匹配前一个表达式1次或多次</td></tr><tr><td>{n}</td><td>匹配前一个表达式n次</td></tr><tr><td>{n,}</td><td>前一个表达式至少出现n次</td></tr><tr><td>flags</td><td></td></tr><tr><td>g</td><td>全局匹配（global）</td></tr><tr><td>i</td><td>不区分大小写（ignoreCase）</td></tr><tr><td>m</td><td>多行搜索</td></tr></tbody></table><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><h4 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\w+/</span>; <span class="hljs-comment">// 字面量</span><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;\\w+&#x27;</span>); <span class="hljs-comment">// 构造函数的字符串参数 </span><br></code></pre></td></tr></table></figure><p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（也就是在转义字符前也要加反斜杠 <code>\</code>）。</p><h4 id="正则表达式（RegExp）的方法"><a href="#正则表达式（RegExp）的方法" class="headerlink" title="正则表达式（RegExp）的方法"></a>正则表达式（RegExp）的方法</h4><ul><li><p>test</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">/a/.test(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// true</span><br>/a/.test(<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p>exec</p><p>regExp是一个有状态的对象，多次对同一个或者相等的字符串执行同样的方法，可以遍历所有匹配的结果。</p><p>相比test会返回更多内容，如果匹配成功会返回一个数组，并且更新lastIndex属性。</p><p>返回的数组其实是类数组，第一项是匹配的字符串，接着是捕获的分组，还有groups、index、input属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(a|d)/g</span>;<br><span class="hljs-keyword">var</span> target = <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-keyword">var</span> arr;<br><span class="hljs-keyword">while</span>(arr = reg.exec(target)) &#123;<br>    <span class="hljs-built_in">console</span>.log(arr);<br>&#125;<br><span class="hljs-built_in">console</span>.log(arr);<br><br><span class="hljs-comment">// 长度为2的数组</span><br><span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, index: 0, input: &quot;abcd&quot;, groups: undefined]</span><br><span class="hljs-comment">// [&quot;d&quot;, &quot;d&quot;, index: 3, input: &quot;abcd&quot;, groups: undefined]</span><br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><h4 id="String对象的方法"><a href="#String对象的方法" class="headerlink" title="String对象的方法"></a>String对象的方法</h4></li><li><p>split</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> values = <span class="hljs-string">&#x27;1,2，3，4,5&#x27;</span>; <span class="hljs-comment">//以中文或英文逗号分隔的值</span><br><span class="hljs-keyword">var</span> arr = values.split(<span class="hljs-regexp">/，|,/</span>); <span class="hljs-comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span><br></code></pre></td></tr></table></figure></li><li><p>match</p><ul><li><p>如果正则表达式有flag g，那么match方法会返回所有匹配的结果，但不会返回捕获组。</p></li><li><p>如果没有，就和exec方法很像，会返回第一个匹配和相关的捕获组，以及index、input、groups属性。如果不匹配，则返回null。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(<span class="hljs-regexp">/[A-Z]/</span>)); <span class="hljs-comment">// [&quot;H&quot;, index: 0, input: &quot;Hello World&quot;, groups: undefined]</span><br><span class="hljs-built_in">console</span>.log(str.match(<span class="hljs-regexp">/[A-Z]/g</span>)); <span class="hljs-comment">// [&quot;H&quot;, &quot;W&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p>replace</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abcd&#x27;</span>.replace(<span class="hljs-regexp">/ab/</span>, <span class="hljs-string">&#x27;AB&#x27;</span>)); <span class="hljs-comment">// ABcd</span><br></code></pre></td></tr></table></figure></li><li><p>search</p><p>返回匹配到位置的索引，匹配失败时返回-1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello World&#x27;</span>.search(<span class="hljs-regexp">/[A-Z]/</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="分组与捕获"><a href="#分组与捕获" class="headerlink" title="分组与捕获"></a>分组与捕获</h2><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>正则表达式中，括号的作用除了使结构更加清晰，还有一个更重要的功能：分组和捕获，也就是可以提取匹配到的数据或进行替换，而这个功能需要配合相关的api使用，比如：exec、match。</p><p>假设我们要匹配一个年月日,可以用这样的正则表达式匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/</span>;<br>reg.exec(<span class="hljs-string">&#x27;2021-06-01&#x27;</span>); <span class="hljs-comment">// [&quot;2021-06-01&quot;, index: 0, input: &quot;2021-06-01&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>虽然匹配了，但要是我们想分别提取到年、月、日的信息呢？考虑下面的正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;<br>reg.exec(<span class="hljs-string">&#x27;2021-06-01&#x27;</span>); <span class="hljs-comment">// [&quot;2021-06-01&quot;, &quot;2021&quot;, &quot;06&quot;, &quot;01&quot;, index: 0, input: &quot;2021-06-01&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>可以看到，返回的数组多了几项，从第二项开始，分别对应的是三个括号内匹配到的内容，这就是分组，在exec方法中可以捕获到，通过RegExp.$1-$9，也可以获取到对应的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">RegExp</span>.$1); <span class="hljs-comment">// 2021console.log(RegExp.$2); // 06console.log(RegExp.$3); // 01</span><br></code></pre></td></tr></table></figure><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><p>除了上面这种引用，还有一种反向引用，也就是正则本身引用之前出现的分组。</p><p>考虑这样的场景：我们要匹配三种格式的日期：yyyy-mm-dd、yyyy/mm/dd、yyyy.mm.dd。或许我们可以这样写正则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;(-|\/|\.)\d&#123;2&#125;/</span>;<br></code></pre></td></tr></table></figure><p>虽然确实可以匹配上面三种格式的日期，但是这个正则表达式同时也匹配了像‘2021-06/02’这样的日期，要怎么样保持连接符号的一致呢？这就需要反向引用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;<br></code></pre></td></tr></table></figure><p>这里的<code>\1</code>，引用的就是前面出现的第一个分组，通过<code>\1</code>、<code>\2</code>、<code>\3</code>这样的转义字符，可以捕获到前面的分组，无论前面匹配到什么，反向引用匹配的都是同样的具体某个字符。</p><p>如果遇到嵌套的括号，则以左括号为准，标识分组顺序。</p><h4 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h4><p>还是上面的例子，我们用括号包裹连接符，创建了分组，但捕获的时候，我们其实并不关心连接符号，而只关心匹配到的年月日，那么我们可以使用非捕获分组<code>(?:)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\d&#123;4&#125;)(?:-|\.|\/)(\d&#123;2&#125;)(?:-|\.|\/)(\d&#123;2&#125;)/</span>;<span class="hljs-built_in">console</span>.log(reg.exec(<span class="hljs-string">&#x27;2021-06-01&#x27;</span>)); <span class="hljs-comment">// [&quot;2021-06-01&quot;, &quot;2021&quot;, &quot;06&quot;, &quot;01&quot;, index: 0, input: &quot;2021-06-01&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><p>如此，我们捕获到的分组，就只是年、月、日了。</p><h2 id="正则的构建"><a href="#正则的构建" class="headerlink" title="正则的构建"></a>正则的构建</h2><p>构建正则之前，我们要考虑几个问题：</p><ul><li><p>是否能使用正则</p></li><li><p>是否有必要使用正则，能用字符串API解决的简单问题，就没有必要使用正则。</p></li><li><p>是否有必要构建一个复杂的正则</p><p>对于密码匹配，假设规则有很多，那么构建出来的可能是一个很庞大的正则表达式，但其实也可以使用很多个小正则来做</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPassword</span>(<span class="hljs-params">string</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!regex1.test(string)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (!regex2.test(string)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-keyword">if</span> (!regex3.test(string)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  ...&#125;<br></code></pre></td></tr></table></figure><p>正则采用的是回溯的方法来匹配，对于太复杂的正则表达式，可能会影响到性能。</p></li></ul><p>构建正则表达式时，还要注意：</p><ul><li>匹配预期的字符串</li><li>不匹配非预期的字符串</li><li>效率优化：<ul><li>使用具体型字符组代替通配符</li><li>使用非捕获型分组</li><li>独立出确定字符</li><li>提取分支的公共部分</li><li>减少分支的数量</li></ul></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h4 id="表单验证-提取"><a href="#表单验证-提取" class="headerlink" title="表单验证/提取"></a>表单验证/提取</h4><p>验证输入的某个值是否符合一个模式，使用match方法，如果匹配失败，返回null，匹配成功，则返回带有捕获分组信息的类数组。</p><h4 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h4><p>从逗号分隔的字符串中提取数据，兼容中文逗号和英文逗号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = value.split(<span class="hljs-regexp">/,|，/</span>);<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://regex101.com/">一个用于测试正则表达式的网站：</a><a href="https://regex101.com/">https://regex101.com/</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/qdlaoyao/js-regex-mini-book">JS正则迷你书</a></p><p><a href="https://ke.qq.com/classroom/index.html#course_id=198477&term_id=100235260&ch_id=327937&vch_id=36&task_id=1511154178525005">NEXT学位课程</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise学习笔记（三）</title>
    <link href="/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="Promise的模式"><a href="#Promise的模式" class="headerlink" title="Promise的模式"></a>Promise的模式</h3><h4 id="Promise-all-…"><a href="#Promise-all-…" class="headerlink" title="Promise.all([…])"></a>Promise.all([…])</h4><p>接收一个可迭代对象（数组/Map/Set），返回一个promise实例pAll。元素通常是promise实例，但也可以是一个thenable对象，也可以是一个立即值。</p><blockquote><p>本质而言，列表中的每个值都会通过Promise.resolve(..)来过滤，以确保要等待的是一个真正的Promise实例</p></blockquote><p>当且仅当这个可迭代对象中的<strong>所有</strong>promise实例都成功时，pAll才成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> pAll = <span class="hljs-built_in">Promise</span>.all([p1,p2])<br><br>pAll.then(<br>    (values) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;all resolved&#x27;</span>,values)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reject&#x27;</span>,reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果pAll是成功的，就执行onResolved函数，其中<strong>values是一个数组</strong>，按照原来的先后顺序，存放promise的结果。</p><p>如果pAll是失败的，就执行onRejected函数，其中reason是第一个抛出的错误信息。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>这个模式叫竞态Promise。同样接收一个可迭代对象（数组/Map/Set），元素的类型可以是promise实例、thenable对象或立即值，并且返回一个promise实例pRace。</p><p>可迭代对象中<strong>第一个完成状态转换</strong>的promise，决定了pRace是成功还是失败：</p><p>（立即值在race中显然没什么意义，因为他一定是第一个resolve的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> pRace = <span class="hljs-built_in">Promise</span>.all([p1,p2]);<br><br>pRace.then(<br>    (res) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;race resolved&#x27;</span>,res)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;race reject&#x27;</span>,reason)<br>&#125;); <br></code></pre></td></tr></table></figure><p>如果第一个完成状态转换的promise实例是成功的，就执行onResolved函数，输出的res是第一个成功的promise的结果。</p><p>如果第一个完成状态转换的promise实例是失败的，就执行onRejected函数，输出的reason是第一个失败的promise的结果。</p><h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>返回一个promise，在上一个promise结束时，无论fulfilled还是rejected，都会执行指定的回调函数，可以避免同样的语句，在resolve和reject中各写一次的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<br><br>p.then(something).finally(cleanup);<br></code></pre></td></tr></table></figure><h3 id="Promise的局限性"><a href="#Promise的局限性" class="headerlink" title="Promise的局限性"></a>Promise的局限性</h3><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>前面也有提到Promise链中的错误很容易被无意中忽略掉。由于一个Promise链仅仅是连接到一起的成员Promise，而没有把整个链标识为一个实体，这意味着，没有外部的方法可以观察到可能发生的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = foo(<span class="hljs-number">42</span>).then(..).then(..);<br></code></pre></td></tr></table></figure><p>如上面一段代码，p指向的是最后一个then返回的promise，没有指定错误处理函数，如果出错了，在外部是没有办法获取到错误通知的。</p><h4 id="单一值"><a href="#单一值" class="headerlink" title="单一值"></a>单一值</h4><p>Promise只能有一个完成值或一个拒绝理由。当我们想要传递多个参数的时候，我们将不得不使用一个对象或者数组传参。</p><p>但如果在Promise链中，每一步都这样封装和解封，就显得十分丑陋和笨重了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(&#123;<br>    foo: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    bar: <span class="hljs-string">&#x27;world&#x27;</span>,<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; foo, bar &#125; = value;<br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="单决议"><a href="#单决议" class="headerlink" title="单决议"></a>单决议</h4><p>很多异步情况下，我们只会获取一个值一次，所以Promise只能被决议一次，不算是个缺点。</p><p>但对于异步的另一种模式，比如：按钮点击</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    click(<span class="hljs-string">&#x27;#btn&#x27;</span>, resolve); <span class="hljs-comment">// 绑定btn的点击事件</span><br>&#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> request(...);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">vals</span>) =&gt;</span> &#123;<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure><p>当第一次点击按钮，可以正常工作，但当第二次点击时，由于promise已经决议，后续的resolve将会被忽略。</p><p>虽然我们可以每次点击都新建一个promise，来解决这个问题，但是每次click都启动一个新的Promise序列，也不够理想。</p><h4 id="无法取消"><a href="#无法取消" class="headerlink" title="无法取消"></a>无法取消</h4><p>一旦创建了一个Promise，并为其注册了完成和拒绝处理函数，那么它就会开始执行，我们没有办法从外部停止它的进程。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise学习笔记（二）</title>
    <link href="/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>Promise的.then方法会返回一个新的Promise（catch同理），所以可以将then链接起来。</p><p><strong>它的值和状态都取决于上一个then的执行情况</strong></p><h4 id="1、上一个then没有返回值"><a href="#1、上一个then没有返回值" class="headerlink" title="1、上一个then没有返回值"></a>1、上一个then没有返回值</h4><p>新promise实例状态为fulfilled，值为undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;xxx&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// p1完成后，p2:&#123;&lt;fulfilled&gt;: undefined&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2、上一个then返回非promise的任意值"><a href="#2、上一个then返回非promise的任意值" class="headerlink" title="2、上一个then返回非promise的任意值"></a>2、上一个then返回非promise的任意值</h4><p>新promise实例状态为fulfilled，值为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>&#125;)<br><span class="hljs-comment">// p1完成后，p2:&#123;&lt;fulfilled&gt;: 6&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3、上一个then显式地返回一个promise"><a href="#3、上一个then显式地返回一个promise" class="headerlink" title="3、上一个then显式地返回一个promise"></a>3、上一个then<strong>显式</strong>地返回一个promise</h4><p>新promise实例的结果等于返回的promise的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">3</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">9</span>);<br>&#125;)<br><span class="hljs-comment">// p1完成后，p2:&#123;&lt;fulfilled&gt;: 9&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4、上一个then没有提供onResolved或者onRejected方法"><a href="#4、上一个then没有提供onResolved或者onRejected方法" class="headerlink" title="4、上一个then没有提供onResolved或者onRejected方法"></a>4、上一个then没有提供onResolved或者onRejected方法</h4><p>如果上一个promise实例是成功的，而then没有提供onResolved方法，就基于上一次resolve的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = p1.then();<br><span class="hljs-comment">// p1完成后，p2:&#123;&lt;fulfilled&gt;: 2&#125;</span><br></code></pre></td></tr></table></figure><h4 id="5、上一个then中抛出错误"><a href="#5、上一个then中抛出错误" class="headerlink" title="5、上一个then中抛出错误"></a>5、上一个then中抛出错误</h4><p>新promise实例状态为rejected，值为抛出的异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-keyword">let</span> p2 = p1.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// p1完成后，p2:&#123;&lt;rejected&gt;: &#x27;fail&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="中断promise链"><a href="#中断promise链" class="headerlink" title="中断promise链"></a>中断promise链</h3><p>如果在某一步后，不想再执行后面的then，从此中断promise链，可以返回一个pending状态的promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">100</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//到此终止</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样写的话，最后一个then和最后一个catch都不会执行（因为无法接收到 fulfilled 或者 rejected 的promise实例）</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>前面已经说过了，Promise中的错误处理，拒绝处理函数会被传递到then函数的第二个参数，或者用catch来捕捉。如果then中的回调函数执行出错，那么这个then的返回一个rejected状态的Promise，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(msg.toLowerCase());<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(err); <span class="hljs-comment">// 永远不会执行</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>p的状态是fulfilled，返回值42，但是在起成功处理函数中，number类型没有toLowerCase方法，所以会抛出一个错误。</p><p>但为什么这个错误不会被我们的错误处理函数捕获呢？</p><p>因为p这个promise已经用值42填充了，变成了fulfiiled状态，它不会再被改变。所以p.then(…)里面的错误，会被通知到p.then(…).then(…)中，但是我们没有在这里捕捉。</p><p>为了避免丢失被忽略或抛弃的Promise错误，一些开发者表示，最佳实践是在最后总以一个catch(..)结束，这种处理叫<strong>异常穿透</strong>。</p><p>如果第一个开头的promise失败了，但是后面的then都没有写onRejected函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(<span class="hljs-number">1</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>那么这个reject(1)就会一层一层透传到最后一个catch（注意：它不是一下子找到最后一个catch的）</p><blockquote><p>无论是then还是catch，它的执行情况都取决于上一个then()</p></blockquote><p>因为then不手动写onRejected函数，默认被这样处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><span class="hljs-keyword">throw</span> reason;<br>&#125;)<br></code></pre></td></tr></table></figure><p>但是不管怎样，在Promise链的最后一步，总存在着未捕获的错误的可能性，尽管这种可能性越来越低。</p><p>有没有办法解决这个问题呢？</p><p>有一些Promise库增加了一些方法，用于注册一个类似“全局未处理拒绝”的处理函数，这样就不会抛出全局错误，而是调用这个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;unhandledrejection&quot;</span>, handler);<br></code></pre></td></tr></table></figure><p>有一种看法是：Promise应该添加一个done函数，从本质上标识标识Promise链的结束。done的回调中抛出的错误，会被当作一个全局未处理的错误，可以在try…catch块中捕获到。</p><p>然而，它并不是ES6标准的一部分，我们可以选择自己实现它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.done = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span><br>        .then(onFulfilled, onRejected)<br>        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>        <span class="hljs-comment">// 抛出一个全局错误</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason<br>        &#125;, <span class="hljs-number">0</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise学习笔记（一）</title>
    <link href="/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/05/22/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>抽象上看，Promise是JavaScript中进行异步编程的解决方案。</p><p>具体来看，Promise是一个对象，它通常用于描述 现在开始执行，一段时间后才能获得结果的异步行为，内部保存了该异步行为的结果。</p><p>Promise对象有且仅有以下3种状态：</p><ul><li>pending：待定（进行中）</li><li>fulfilled：成功</li><li>rejected：失败</li></ul><p>一个Promise的状态转换仅有以下2种，<strong>Promise一旦决议，就会一直保持其决议结果（fulfilled或rejected）不变</strong>：</p><ul><li>pending 到 fulfilled</li><li>pending  到 rejected</li></ul><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>Promise对象构造器接收一个executor执行器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//这个代码块是executor</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>执行器通常承担2个任务：</p><ul><li>初始化一个异步行为</li><li>控制状态的最终转换</li></ul><p>执行器接收两个函数作为参数，其中：</p><ul><li>resolve：用于将状态 pending 转换成 fulfilled</li><li>reject：用于将状态 pending 转换成 rejected</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>resolve()<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在setTimeout真正被执行的1000ms后，对象p的状态从pending转换成fulfilled，并将resolve对应的回调函数放入异步队列（等待执行）。</p><h3 id="实例方法-then"><a href="#实例方法-then" class="headerlink" title="实例方法.then( )"></a>实例方法.then( )</h3><p>then方法可接收2个函数作为参数</p><ul><li>第一个为onResolved：当executor中执行resolve( )的时候，就会进入onResolved这个函数，传递成功的value</li><li>第二个为onRejected：当executor中执行reject( )的时候，就会进入onRejected这个函数，传递失败的reason</li></ul><p>我们可以把这2个函数单独写在外部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise执行成功&#x27;</span>)<br>    resolve(<span class="hljs-number">3</span>)<br>&#125;)<br><br>p.then(onResolved,onRejected)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onResolved</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolved：&#x27;</span>+ value)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRejected</span>(<span class="hljs-params">reason</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rejected：&#x27;</span>+ reason)<br>&#125;<br><span class="hljs-comment">//输出如下：</span><br><span class="hljs-comment">//promise执行成功</span><br><span class="hljs-comment">//resolved：3</span><br></code></pre></td></tr></table></figure><p>也可以将函数直接写在then括号内（省略函数名的定义）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise执行成功&#x27;</span>)<br>    resolve(<span class="hljs-number">3</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rejected：&#x27;</span>+ value)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rejected：&#x27;</span>+ reason)<br>&#125;)<br><span class="hljs-comment">//与上面的写法完全等价</span><br></code></pre></td></tr></table></figure><p>then方法的参数是可选的</p><p>当参数只有onResolved的时候，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">3</span>)<br>&#125;)<br><br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resolved：&#x27;</span>+ value)<br>&#125;)<br></code></pre></td></tr></table></figure><p>当参数只有onRejected的时候，需要把第一个参数设置为null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>)<br>&#125;)<br><br>p.then(<span class="hljs-literal">null</span>,<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;rejected：&#x27;</span>+reason)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="实例方法-catch"><a href="#实例方法-catch" class="headerlink" title="实例方法 .catch( )"></a>实例方法 .catch( )</h3><p>catch专门用于处理失败的promise对象，它只接收一个 onRejected函数作为参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>)<br>&#125;)<br><br>p.catch(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="如何判断Promise或者类似于Promise的值"><a href="#如何判断Promise或者类似于Promise的值" class="headerlink" title="如何判断Promise或者类似于Promise的值"></a>如何判断Promise或者类似于Promise的值</h3><p>虽然Promise是通过new Promise(…)语法创建，但如果用<code>p instanceof Promise</code>来检查某个值是否为promise，是不全面的，因为：</p><ul><li>Promise的值可能是从其他浏览器窗口（iframe）中接收到的，这个窗口的Promise可能和当前窗口的不一样，所以无法识别Promise实例</li><li>某一些库或框架会实现自己的Promise，而不是使用原生的ES6 Promise</li></ul><p>所以，识别Promise就是定义一个thenable的东西，任何具有then(…)方法的对象和函数，都被称为Promise一致的thenable。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> thenable = &#123;<br><span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">res</span>)</span> &#123;<br><span class="hljs-built_in">setTimeout</span>(res, <span class="hljs-number">3000</span>)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Promise</span>.resolve()<br>.then(<span class="hljs-function">()=&gt;</span>thenable)<br>.then(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3秒过去&#x27;</span>));<br><br><span class="hljs-comment">// 2</span><br>!<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">() =&gt;</span> thenable<br><br><span class="hljs-keyword">await</span> sleep();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3秒过去&#x27;</span>);<br>&#125;();<br></code></pre></td></tr></table></figure><p>如上面一段代码，无论是哪一种写法，都会经过3秒然后打印。证明判断一个对象是不是Promise或行为方式类似于Promise，仅仅判断它是否有 <code>then</code> 函数即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<br>    p !== <span class="hljs-literal">null</span> &amp;&amp; <br>   (<br><span class="hljs-keyword">typeof</span> p === <span class="hljs-string">&quot;object&quot;</span> ||<br>    <span class="hljs-keyword">typeof</span> p === <span class="hljs-string">&quot;function&quot;</span><br>   ) &amp;&amp;<br>    <span class="hljs-keyword">typeof</span> p.then === <span class="hljs-string">&quot;function&quot;</span><br>  ) &#123;<br>    <span class="hljs-comment">// 这是一个thenable对象</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 这不是一个thenable对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们无意给某个对象加上then函数，却不希望它被当作Promise或者thenable，那恐怕会事与愿违，他会被自动识别为thenable，按照特定的规则处理。所以这可能是有害的，可能导致难以追踪的bug。</p><blockquote><p>这种类型检测叫鸭子类型（duck typing）: When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.</p></blockquote><h3 id="为什么要使用Promise"><a href="#为什么要使用Promise" class="headerlink" title="为什么要使用Promise"></a>为什么要使用Promise</h3><p>如果用普通的回调来提供异步方案，会有一些信任的问题，如下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// A</span><br>ajax(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">..</span>) </span>&#123;<br>    <span class="hljs-comment">// C</span><br>&#125;);<br><span class="hljs-comment">// B</span><br></code></pre></td></tr></table></figure><p>A和B发生于现在，C可能会延迟到将来发生，并且是在第三方的控制下。这种控制反转会出现五个问题：</p><ul><li>回调调用次数太少或太多（第三方可能会不如我们所期待地多次调用回调函数）</li><li>调用回调过早（在追踪之前）</li><li>调用回调过晚（甚至没有调用）</li><li>没有把所需要的环境/参数传给回调函数</li><li>吞掉可能出现的错误或异常</li></ul><p>Promise的特性就是用来解决这些问题的：</p><ul><li><p>解决回调调用过早或过晚：即使是立即完成的promise，其回调then函数里的内容也总是会被放到微任务队列里，异步执行，即使有多个回调函数，它们的执行是独立的，不会受到影响。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;C&#x27;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;)<br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;B&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">// A B C</span><br></code></pre></td></tr></table></figure></li><li><p>解决回调次数过少（未调用）:我们可以设定一个超时函数，并且用promise.race来解决超时未调用的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">delay</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Timeout!&#x27;</span>);<br>        &#125;);<br>    &#125;);<br>&#125;<br><span class="hljs-built_in">Promise</span>.race([p, timeout(<span class="hljs-number">3000</span>)]).then(resCb, rejCb);<br><span class="hljs-comment">// 当超时或者p抛出错误，都会调用rejCb</span><br></code></pre></td></tr></table></figure></li><li><p>解决回调次数过多：若代码试图多次调用resolve或reject，Promise只会接受第一次决议，并忽略任何后续的调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    resolve(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-comment">// 之后的决议全部忽略</span><br>    resolve(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    reject(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;);<br>p.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(value); &#125;, <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123; <span class="hljs-built_in">console</span>.error(reason); &#125;); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>解决未能传递参数/环境值：Promise的resolve和reject都只能传一个参数，第二个参数及之后的都会被忽略，如果未显式定义，则这个值为undefined，详情见后文的链式调用流。</p></li><li><p>解决吞掉异常或错误的问题：每个then函数都会返回另一个promise，所以任何地方抛出错误，都会导致相应的promise被拒绝，可以在catch或者then的第二个参数中定义异常处理，详情见后文的错误处理。</p></li></ul><p>参考文章：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/s4YE7upruEcqdWwtuK1e6Q">再一次深入理解Promise</a></p><p>《你不知道的JavaScript》(中卷）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>读《你不知道的JavaScript》——对象不变性</title>
    <link href="/2021/04/06/%E8%AF%BB%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/"/>
    <url>/2021/04/06/%E8%AF%BB%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>我们知道，ES6引入的const是用来定义常量的，对于基本数据类型来说，变量存储的是数据的值，所以用起来没问题，但当我们使用const定义一个数组或者对象时，由于存储的是对象的地址，所以即使我们修改了对象的某一键值，或者为数组增加、删除一项，它的存储地址，所以依旧是常量，这有时候不是我们想要的。</p><p>那么要如何定义一个“真正”的对象类型的常量呢？</p><h4 id="使用对象的属性描述符"><a href="#使用对象的属性描述符" class="headerlink" title="使用对象的属性描述符"></a>使用对象的属性描述符</h4><p>使用<code>configurable: false</code>和<code>writable: false</code>创建一个常量属性(不可修改、重定义或删除)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(myObj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  configurable: <span class="hljs-literal">false</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h4><p>禁止一个对象添加新的属性。原有的属性可以修改可以使用delete删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myObj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-built_in">Object</span>.preventExtensions(myObj);<br>myObj.b = <span class="hljs-number">3</span>;<br>myObj.b; <span class="hljs-comment">// undefined</span><br>myObj.a = <span class="hljs-number">3</span>;<br>myObj.a; <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">delete</span> myObj.a <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h4><p><code>Object.seal</code>:创建一个“密封”的对象，实际上是在现有的对象上调用<code>Object.preventExtensions(..)</code>并把所有的现有属性标记为<code>configurable: false</code></p><p>密封之后，不能添加新属性，也不能重新配置或删除任何现有属性，但是可以修改现有属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">Object</span>.seal(obj);<br>obj.b = <span class="hljs-number">1</span>;<br>obj.b <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>    configurable: <span class="hljs-literal">true</span><br>&#125;) <span class="hljs-comment">// Uncaught TypeError: Cannot redefine property: a</span><br>obj.a = <span class="hljs-number">3</span><br>obj.a <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h4><p><code>Object.freeze(..)</code>创建一个冻结对象，实际上是在现有的对象上调用<code>Object.seal(..)</code>并把所有的“数据访问”属性标记为<code>writable: false</code>,这样就无法修改属性的值。这个方法是级别最高的不可变性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class=