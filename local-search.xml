<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React Hook的闭包陷阱</title>
    <link href="/2021/03/08/React-Hook%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/"/>
    <url>/2021/03/08/React-Hook%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包陷阱"><a href="#什么是闭包陷阱" class="headerlink" title="什么是闭包陷阱"></a>什么是闭包陷阱</h2><p>所谓的闭包陷阱，就是在函数式组件中，我们拿不到通过useState定义的变量的最新值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs react">const App &#x3D; ()&#x3D;&gt;&#123;<br>  const [count,setCount] &#x3D; useState(0)<br>  useEffect(()&#x3D;&gt;&#123;<br>    const timeId &#x3D; setInterval(()&#x3D;&gt;&#123;<br>      console.log(count);<br>    &#125;,1000)<br>    return ()&#x3D;&gt;&#123;clearInterval(timeId)&#125;<br>  &#125;,[])<br>  return (<br>    &lt;div&gt;<br>    &lt;span&gt;&#123;count&#125;&lt;&#x2F;span&gt;<br>      &lt;button onClick&#x3D;&#123;()&#x3D;&gt;&#123;setCount(count+1)&#125;&#125;&gt;ADD&lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说，这段代码我们点击button，页面上渲染的count值是会增加，但控制台打印的值，始终会是0。</p><p>事实上，esLint也会报一个warning：</p><p><img src="/2021/03/08/React-Hook%E7%9A%84%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1/%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1.png" alt="闭包陷阱"></p><p>始终输出0的原因是，函数式组件每次渲染都会有自己的Effect函数和count值，我们依赖数组设为[]，后面useEffect也并没有更新了，所以setInterval里读取的都是第一次渲染的count，也就是0。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>在依赖数组中加入count</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs react">useEffect(()&#x3D;&gt;&#123;<br>    const timeId &#x3D; setInterval(()&#x3D;&gt;&#123;<br>      console.log(count);<br>    &#125;,1000)<br>    return ()&#x3D;&gt;&#123;clearInterval(timeId)&#125;<br>  &#125;,[count])<br></code></pre></td></tr></table></figure><p>这样每次渲染，都会更新useEffect函数，拿到最新的count值。</p><ol start="2"><li>useRef存储变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">const [count, setCount] &#x3D; useState(0);<br>const latestCount &#x3D; useRef();<br>latestCount.current &#x3D; count;<br>useEffect(()&#x3D;&gt;&#123;<br>const timeId &#x3D; setInterval(()&#x3D;&gt;&#123;<br>console.log(latestCount.current)<br>&#125;, 1000);<br>return () &#x3D;&gt; clearInterval(timeId);<br>&#125;, []);<br></code></pre></td></tr></table></figure><h2 id="导致闭包陷阱的原因"><a href="#导致闭包陷阱的原因" class="headerlink" title="导致闭包陷阱的原因"></a>导致闭包陷阱的原因</h2><ol><li>异步函数</li><li><code>window.addEventListener</code>绑定事件</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数式组件的渲染</title>
    <link href="/2021/03/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
    <url>/2021/03/08/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<p>“<strong>组件每一次渲染都会有自己的props和state。每一次渲染都会有自己的事件处理函数</strong>。”接下来，我们来深刻理解这句话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">function Counter()&#123;<br>  const [count, setCount] &#x3D; useState(0);<br>  return (<br>  &lt;p&gt;you clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count+1)&#125;&gt;+++&lt;&#x2F;button&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码里，我们如果点击button，显示的count的值确实会增加。它的原理是count“监听”状态的变化然后自动更新吗？其实并不是。count不是双向绑定或者“watcher”或者其他任何东西，它只是一个普通的变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs react">const count &#x3D; 0;<br>...<br>&lt;p&gt;you clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br></code></pre></td></tr></table></figure><p>初始状态下，count值是0。当调用setCount(1)的时候，React重新渲染了组件，这次count的值是1。也就是说每次渲染拿到的count值是独立的，不是同一份。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs react">&#x2F;&#x2F; During first render<br>function Counter() &#123;<br>  const count &#x3D; 0; &#x2F;&#x2F; Returned by useState()<br>  &#x2F;&#x2F; ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>  &#x2F;&#x2F; ...<br>&#125;<br><br>&#x2F;&#x2F; After a click, our function is called again<br>function Counter() &#123;<br>  const count &#x3D; 1; &#x2F;&#x2F; Returned by useState()<br>  &#x2F;&#x2F; ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>  &#x2F;&#x2F; ...<br>&#125;<br><br>&#x2F;&#x2F; After another click, our function is called again<br>function Counter() &#123;<br>  const count &#x3D; 2; &#x2F;&#x2F; Returned by useState()<br>  &#x2F;&#x2F; ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>  &#x2F;&#x2F; ...<br>&#125;<br></code></pre></td></tr></table></figure><p>关键在于，任意一次渲染中，const常量是不会变化的，我们看到的输出变化，是因为组件被重新调用了，并且传入了不同的参数，这个参数独立于其他任何一次渲染。</p><p>对于基本变量来说是这样的，那事件处理函数的情况呢？</p><p>答案其实一样，函数式组件的渲染，每次都会从上到下执行一遍代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs react">function Counter()&#123;<br>  const [count, setCount] &#x3D; useState(0);<br>  function handleClick()&#123;<br>    setTimeout(() &#x3D;&gt; &#123;<br>      console.log(count);<br>    &#125;,5000);<br>  &#125;<br>  return (<br>    &lt;&gt;<br>      &lt;p&gt;you clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count+1)&#125;&gt;+++&lt;&#x2F;button&gt;<br>      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;console&lt;&#x2F;button&gt;<br>    &lt;&#x2F;&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们在点击完console button后的5s时间内点击了多次+++按钮，请问会输出什么？答案是：0。</p><p>它的原理就类似于普通函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">person</span>)</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(person.name)&#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><span class="hljs-keyword">let</span> someone = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Dan&quot;</span>&#125;;<br>sayHi(someone); <span class="hljs-comment">// &quot;Dan&quot;</span><br><br>someone = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Mike&quot;</span>&#125;;<br>sayHi(someone); <span class="hljs-comment">// &quot;Mike&quot;</span><br><br>someone = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>&#125;;<br>sayHi(someone); <span class="hljs-comment">// &quot;John&quot;</span><br></code></pre></td></tr></table></figure><p>即使在console.log执行之前，someone已经被赋予了新值，但在sayHi函数内，person会和某次调用的someone关联，也就是说每次调用的person都是独立的，虽然名字一样，但保存在不同的空间里。</p><p>同样的，组件每次渲染都会有新的handleClick函数，它会记住这次渲染的count值。虽然名字和之前渲染的handleClick一样，但他们是独立的。也就是说，事件处理函数“属于”某一次特定的渲染。</p><p>再来看看useEffect这个Hook，它和上面分析的结果一样，每次渲染都会有自己的Effects。直接上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs react">function Counter()&#123;<br>  const [count, setCount] &#x3D; useState(0);<br>  useEffect(() &#x3D;&gt; &#123;<br>    setTimeout(()&#x3D;&gt;&#123;<br>      console.log(count);<br>    &#125;, 3000);<br>  &#125;)<br>  return (<br>    &lt;div&gt;<br>      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;<br>      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;<br>        Click me<br>      &lt;&#x2F;button&gt;<br>    &lt;&#x2F;div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码，如果在3s内连续点击五次，会依次输出<code>0,1,2,3,4,5</code>。因为每次调用effect，它看到的都是属于本次渲染的唯一的count。</p><p>总的来说，每一次渲染的组件都会拥有它自己的所有东西（props、state、事件处理函数、effects、定时器、API调用等）。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>函数式组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>受控组件与非受控组件（三）</title>
    <link href="/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>非受控组件指的是表单的数据不再由React组件进行管理，而是交给DOM节点处理，可以使用refs属性来从DOM节点中获取到数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs react">class NameForm extends React.Component &#123;<br>  constructor(props)&#123;<br>    super(props);<br>    this.input &#x3D; React.createRef();<br>  &#125;<br>  handleSubmit(e)&#123;<br>    console.log(this.input.current.value);<br>    e.preventDefault();<br>  &#125;<br>  render()&#123;<br>    return (<br>    &lt;form onSubmit&#x3D;&#123;this.handleSubmit.bind(this)&#125;&gt;<br>      &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.input&#125; &#x2F;&gt;<br>        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; &#x2F;&gt;<br>      &lt;&#x2F;form&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非受控组件将代码存储在真实的DOM节点中，可以节省很多代码。</p><p>在React组件中，表单元素的value值会覆盖这个DOM节点，如果我们想要给组件添加默认值，又不影响后续的输入，可以使用<code>defaultValue</code>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;input defaultValue&#x3D;&quot;hi&quot; ref&#x3D;&#123;this.input&#125; &#x2F;&gt;<br></code></pre></td></tr></table></figure><h2 id="什么时候用受控组件或非受控组件"><a href="#什么时候用受控组件或非受控组件" class="headerlink" title="什么时候用受控组件或非受控组件"></a>什么时候用受控组件或非受控组件</h2><p>受控组件的特点是它和state是类似双向绑定的，也就是通过state可以实时拿到表单中的数据。</p><blockquote><p>The state gives the value to the input, and the input asks the <code>Form</code> to change the current value.</p></blockquote><p>所以受控组件能快速响应表单内容的变化，它适用于以下场景：</p><ul><li>输入实时验证</li><li>依照某个条件禁用或不禁用一个button</li><li>强制输入规范</li><li>多个输入映射到同一份data</li></ul><p>非受控组件的使用场景主要有：</p><ul><li>对DOM 元素焦点的控制、内容选择或者媒体播放；</li><li>通过对DOM元素控制，触发动画特效；</li><li>通第三方DOM库的集成。</li></ul><p>参考资料：</p><p><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">关于受控和非受控组件</a></p><p><a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html">React官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>受控组件与非受控组件（二）</title>
    <link href="/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>讲非受控组件之前，我们先理解Refs and the DOM的概念。</p><h2 id="Refs-and-DOM"><a href="#Refs-and-DOM" class="headerlink" title="Refs and DOM"></a>Refs and DOM</h2><p>在React的典型数据流中，props是父子组件的唯一交互方式。要修改子组件，就要通过修改props来重新渲染子组件。而refs属性，则提供了在典型数据流以外，强制修改子组件的方式。被修改的子组件可能是一个DOM元素，也有可能是一个组件React实例。</p><h4 id="使用refs属性"><a href="#使用refs属性" class="headerlink" title="使用refs属性"></a>使用refs属性</h4><p>通过<code>React.createRef()</code>函数创建一个ref，并通过ref属性附加到React元素上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs react">class MyComponent extends React.Component &#123;<br>constructor()&#123;<br>super();<br>this.myRef &#x3D; React.createRef();<br>  this.handleClick &#x3D; this.handleClick.bind(this);<br>&#125;<br>  handleClick()&#123;<br>    console.log(this.myRef.current)<br>  &#125;<br>render()&#123;<br>return &lt;button ref&#x3D;&#123;this.myRef&#125; onClick&#x3D;&#123;this.handleClick&#125;&gt;点击&lt;&#x2F;button&gt;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 ref 被传递给 <code>render</code> 中的元素时，对该节点的引用可以在 ref 的 <code>current</code> 属性中被访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">const node &#x3D; this.myRef.current<br></code></pre></td></tr></table></figure><p>如果<code>ref</code>属性属于一个HTML元素，则接收底层 DOM 元素作为<code>current</code>属性。</p><p>如果<code>ref</code>属性属于一个class组件，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</p><p>React组件会在挂载的时候给current属性传入DOM元素，并在卸载的时候传入null值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p><h4 id="refs转发"><a href="#refs转发" class="headerlink" title="refs转发"></a>refs转发</h4><p>不能在函数组件上使用ref，因为函数组件没有实例。但可以在函数式组件内部使用（使用useRef hook），只要它指向一个DOM或者class组件实例。要想在函数式组件中使用ref属性，可以使用forward ref：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">const FancyButton &#x3D; React.forwardRef((prop, refProp) &#x3D;&gt; &#123;<br>  return &lt;button ref&#x3D;&#123;refProp&#125;&gt;&lt;&#x2F;button&gt;<br>&#125;)<br>const refForward &#x3D; React.createRef();<br>&lt;FancyButton ref&#x3D;&#123;refForward&#125;&gt;&lt;&#x2F;FancyButton&gt;<br></code></pre></td></tr></table></figure><p>这样通过ref可以访问到button元素，这个FancyButton接收了ref，并向下传递给子组件，就叫ref转发。</p><h4 id="refs回调"><a href="#refs回调" class="headerlink" title="refs回调"></a>refs回调</h4><p>通过ref回调可以在父组件在访问到子组件。通过给ref属性传入一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs react">function CustomTextInput(props) &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;input ref&#x3D;&#123;props.inputRef&#125; &#x2F;&gt;&lt;&#x2F;div&gt;<br>  );<br>&#125;<br><br>class Parent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;CustomTextInput<br>        inputRef&#x3D;&#123;el &#x3D;&gt; this.inputElement &#x3D; el&#125; &#x2F;&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们在父组件中把回调函数以属性的方式传给子组件，子组件把ref属性设置为这个回调函数，这样，父组件的<code>inputElement</code>就指向子组件的input元素了。</p><p>参考资料：</p><p><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">React官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>受控组件与非受控组件（一）</title>
    <link href="/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>React里面，HTML的表单元素工作方式和其他DOM不太一样。表单元素通常会维护内部的状态，这些状态会根据用户的输入而更新。而React中，可变状态通常保存在state中，并且只能通过setState更新。</p><p>所以React就把这两种方式结合起来，让state成为React的“唯一数据源”。并且React还控制着用户的输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><p>所谓的受控组件和非受控组件，是针对表单元素而言的。</p><p>受控组件有以下几个特点：</p><ul><li>表单元素依赖于状态，它的值始终由React的state来驱动。</li><li>表单元素的修改，会实时映射到state，跟双向绑定类似。</li><li>必须继承React.Component</li><li>受控组件必须在表单上使用onChange来绑定事件</li></ul><h4 id="常见的受控组件："><a href="#常见的受控组件：" class="headerlink" title="常见的受控组件："></a>常见的受控组件：</h4><ol><li>input</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.state = &#123;<br>value: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">this</span>.handleChange = handleChange.bind(<span class="hljs-built_in">this</span>);<br><span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">e</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">value</span>: e.target.value&#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> (<br>&lt;form&gt;<br>&lt;input<br>value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;<br>onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125;<br>/&gt;<br>&lt;/form&gt;<br>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但如果input标签的type取值为“file”，它的value是只读的，所以它是非受控组件。</p><ol start="2"><li>textarea</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextAreaForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>constructor()&#123;<br><span class="hljs-keyword">this</span>.state = &#123;<br>value: <span class="hljs-string">&quot;默认文本&quot;</span><br>&#125;<br>&#125;<br>render()&#123;<br><span class="hljs-keyword">return</span> (<br>&lt;textarea <br>        value=&#123;<span class="hljs-keyword">this</span>.state.value&#125; <br>        onChange=&#123;(e) =&gt; &#123;<span class="hljs-keyword">this</span>.setState(&#123;value: e.target.value&#125;)&#125;&#125;<br>/&gt;<br>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>select </p><p>React不会使用selected属性，而是在selected标签里用value表示选中项。</p><p>对于多选框。可以在value里传入一个数组。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">cosntructor</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.state = &#123;<br>value: <span class="hljs-string">&quot;item1&quot;</span><br><span class="hljs-comment">// value: [&quot;item1&quot;, &quot;item2&quot;]</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> (<br>&lt;select<br>      &#123;<span class="hljs-comment">/* mutiply=&#123;true&#125; */</span>&#125;<br>value=&#123;<span class="hljs-built_in">this</span>.state.value&#125;<br>onChange=&#123;<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-built_in">this</span>.setState(&#123;e.target.value&#125;)&#125;&#125;<br>&gt;<br>          &lt;option value=<span class="hljs-string">&quot;item1&quot;</span>&gt;item1&lt;/option&gt;<br>          &lt;option value=<span class="hljs-string">&quot;item2&quot;</span>&gt;item2&lt;/option&gt;<br>          &lt;option value=<span class="hljs-string">&quot;item3&quot;</span>&gt;item3&lt;/option&gt;<br>&lt;/select&gt;<br>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>我们必须给受控组件添加onChange事件监听函数，否则浏览器会报错：<img src="/2021/03/07/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B61.png" alt="受控组件1"></p><p>解决办法：设置readOnly属性或者添加onChange函数</p></li><li><p>当我们给input的value属性指定一个和state相关的值，或者没有在onChange函数中写setState逻辑，会阻止用户的输入，但指定null或undefined除外：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 用户无法输入<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.value&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>&#123;&#125;&#125;<br>// 用户可以输入<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;null&#125;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;undefined&#125;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>有时候，使用受控组件是件很麻烦的事情，需要为数据变化的每一种方式都编写处理函数，并通过一个React组件传递所有的state。如果将非React代码转成React代码或者做React代码和非React代码集成时，会非常繁琐。这些情况下，可以引用非受控组件——表单的另一种实现方式。</p><p>参考资料：</p><p><a href="https://zh-hans.reactjs.org/docs/forms.html#controlled-components">React官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>i18n(Internationalization)</title>
    <link href="/2021/02/25/i18n%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/"/>
    <url>/2021/02/25/i18n%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>语言包作为作为静态资源单独保存</p></li><li><p>每种语言对应一个文件</p></li><li><p>切换语言设置时，语言文件随之切换 </p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2></li></ul><p>i18next：目前最主流的框架   react-i18next：提供了更多面向react的api（HOC、hooks）</p><h2 id="配置i18n"><a href="#配置i18n" class="headerlink" title="配置i18n"></a>配置i18n</h2><p>首先创建i18n文件夹，创建configs.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs react">import i18n from &quot;i18next&quot;;<br>import &#123; initReactI18next &#125; from &quot;react-i18next&quot;;<br></code></pre></td></tr></table></figure><p>进行下一步之前，我们要先引入语言文件包，这里我使用中文、英文两种语言，文件是json格式的，所以引入了中文版zh.json和英文版en.json。其实就是普通的json对象，两个文件的结构一样，只有最后的值不同，一个是中文一个是英文。</p><p>接着，我们要在配置文件中引入这两个文件，然后定义一个代表语言资源的本地变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs react">import translation_en from &#39;.&#x2F;en.json&#39;<br>import translation_zh from &#39;.&#x2F;zh.json&#39;<br><br>const resources &#x3D; &#123;<br>  en: &#123;<br>    translation: translation_en<br>  &#125;,<br>  zh: &#123;<br>    translation: translation_zh<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着按照官方文档进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs react">i18n<br>  .use(initReactI18next) &#x2F;&#x2F; 通过react-i18next进行初始化<br>  .init(&#123;<br>    resources,  &#x2F;&#x2F; 传入本地资源变量<br>    lng: &quot;zh&quot;,  &#x2F;&#x2F; 默认语言：zh<br>&#x2F;&#x2F; keySeparator为true，代表我们可以通过链式结构访问字符串，如：&quot;header.slogan&quot;<br>    &#x2F;&#x2F; keySeparator: false, &#x2F;&#x2F; we do not use keys in form messages.welcome<br><br>    interpolation: &#123;<br>      &#x2F;&#x2F; 不会强行把html字符串转换为普通字符串<br>      escapeValue: false &#x2F;&#x2F; react already safes from xss<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><p>最后导出配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">export default i18n<br></code></pre></td></tr></table></figure><h2 id="使用i18n"><a href="#使用i18n" class="headerlink" title="使用i18n"></a>使用i18n</h2><p>i18next的基本原理是Context，就是在全局注入provider，然后子组件中使用相应API获取数据。但实际上，我们只需在index.js文件中引入配置文件，就大功告成了，因为react-i18next这个框架在初始化对象的时候，就帮我们完成了context API的注入。所以我们现在已经可以在各组件中使用这个context API了。</p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件中，我们使用高阶函数完成语言的注入，导入react-i18next的高阶函数withTranslation，并修改组件的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; withTranslation &#125; from &quot;react-i18next&quot;<br>class HomeComponent extends React.Component &#123;<br>  ...<br>&#125;<br>export default withTranslation()(HomeComponent)<br></code></pre></td></tr></table></figure><p>这个高阶函数需要写两个小括号，第一个代表命名空间，第二个才是我们的组件。这样，我们就可以在props中访问到函数t了，利用这个函数，我们可以以字符串的形式访问到语言文件的json对象。</p><p>因为要在props中使用t，我们要先传入i18n的typescript定义。导入WithTranslation，这个就是typescript的类型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; withTranslation, WithTranslation &#125; from &quot;react-i18next&quot;;<br>type PropsType &#x3D; WithTranslation<br>class HomeComponent extends React.Component&lt;PropsType&gt; &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们就用t函数来替换硬编码的字符串。比如说把首页的“爆款推荐”换成<code>&#123;t(&quot;home_page.hot_recommend&quot;)&#125;</code>。</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>在函数式组件中调取全局数据，用的是钩子函数，首先，我们要引入useTranslation这个hook</p><p><code>import &#123; useTranslation &#125; from &#39;react-i18next&#39;;</code></p><p>然后直接使用得到t函数即可，之后的用法和类组件一模一样。</p><p><code>const &#123; t &#125; = useTranslation();</code></p><h2 id="语言切换"><a href="#语言切换" class="headerlink" title="语言切换"></a>语言切换</h2><p>现在，我们可以正常显示语言了，还差最后一步，就是实现中英切换。由于language保存在store中，所以我们点击语言切换时，用reducer来改变store中的状态，在处理全局language数据的同时，我们调用i18next的API来切换语言即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">&#x2F;&#x2F; languageReducer.ts<br>import i18n from &#39;i18next&#39;;<br>switch (action.type) &#123;<br>    case CHANGE_LANGUAGE:<br>    &#x2F;&#x2F; 传入的是语言的key<br>      i18n.changeLanguage(action.payload);<br>      return &#123; ...state, language: action.payload &#125;;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>现在我们功能已经实现了，但是这么实现是有问题的。根据redux的定义所以的reducer都是纯函数，也就是没有副作用的函数，但是我们调用i18n.changeLanguage()这个函数时，这个reducer就不再是纯函数了，所以我们要使用中间件来改进。</p><p>在middlewares文件夹中创建changeLanguage.ts，编写中间件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; Middleware &#125; from &#39;redux&#39;;<br>import &#123; CHANGE_LANGUAGE &#125; from &quot;..&#x2F;language&#x2F;languageActions&quot;;<br>import i18n from &quot;i18next&quot;;<br><br>export const changeLanguage : Middleware &#x3D; (store) &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;<br>  if(action.type &#x3D;&#x3D;&#x3D; CHANGE_LANGUAGE)&#123;<br>    i18n.changeLanguage(action.payload);<br>  &#125;<br>  next(action);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在store文件中引入即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">const store &#x3D; configureStore(&#123;<br>  reducer: persistedReducer,<br>  middleware: (getDefaultMiddleware) &#x3D;&gt; [...getDefaultMiddleware(), changeLanguage, actionLog],<br>  devTools: true,<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在我们就完全实现了语言的切换功能。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>i18n</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Redux</title>
    <link href="/2021/02/17/Redux/"/>
    <url>/2021/02/17/Redux/</url>
    
    <content type="html"><![CDATA[<h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><ol><li>用户通过action creator创建action并派发dispatch action。</li><li>store收到之后自动调用相应的reducer，传入当前的state和收到的action，返回新的state。</li><li>state一旦发生变化，会调用监听函数，通知订阅了store的组件（store.subscribe(listener)）。</li><li>Reacr component中可以通过store.getState()获取到store的状态。</li></ol><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt="flow" /> <h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>上述流程中，我们的reducer只能处理一些同步的、无副作用的action，那一步操作怎么办？像数据获取这些有副作用的操作怎么办？这时我们可以使用redux中的新工具——中间件（middleware）。</p><p>所谓中间件，就是对原来的store.dispatch进行封装，在发出action和执行reducer之间添加一些操作。</p><h4 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a>中间件的用法</h4><p>我们既可以使用现有的中间件（redux-thunk、redux-logger等），也可以自定义中间件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs react">const middleWare &#x3D; (store) &#x3D;&gt; (next) &#x3D;&gt; (action) &#x3D;&gt; &#123;<br>&#x2F;&#x2F;派发action之前进行一些操作<br>  ...<br>  &#x2F;&#x2F;dispatch这个action<br>next(action)<br>  &#x2F;&#x2F;action执行后<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用中间件，只需在createStore的时候将applyMiddlewares(thunk, logger)参数传入即可。</p><h2 id="异步操作的基本思路（使用redux-thunk）"><a href="#异步操作的基本思路（使用redux-thunk）" class="headerlink" title="异步操作的基本思路（使用redux-thunk）"></a>异步操作的基本思路（使用redux-thunk）</h2><p>假设说我们要向服务器请求数据，而且这个数据在多个模块中要用到，那么我们可以考虑在store中获取数据，并使用redux-thunk中间件，派发三种action，分别是</p><ul><li>fetchDataStart</li><li>fetchDataSuccess</li><li>fetchDataFail</li></ul><p>维护state对象，包含loading、data、error三个属性，分别表示是否加载数据中，获取到的data，出错信息。</p><p>我们的目标是将获取数据的操作放到store中，也就是在component中dispatch一个类似giveMeData这样的action，然后store收到这个action之后自动执行API请求、请求成功或失败后的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs react">&#x2F;&#x2F;在react component中<br>componentDidMount()&#123;<br>  dispatch(giveMeDataActionCreator())<br>&#125;<br></code></pre></td></tr></table></figure><p>一般的action creator返回的都是一个对象，这没有办法满足我们的需求，这时我们就要引入redux-thunk这个中间件，它封装了dispatch这个方法，让dispatch多支持一种参数类型——函数类型。</p><p>giveMeDataCreator返回一个函数，带有dispatch和getState两个redux方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs react">export const giveMeDataCreator &#x3D; () : ThunkAction &#x3D;&gt; (dispatch, getState) &#x3D;&gt; &#123;<br>  dispatch(fetchDataStartCreator());<br>  try&#123;<br>    const &#123; data &#125; &#x3D; await axios.get(...);<br>    dispatch(fetchDataSuccessCreator(data));<br>  &#125; catch (e) &#123;<br>    dispatch(fetchDataFailCreator(e.message));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个action creator中，我们连续发送两个action，让reducer完成相关操作。而我们的中间件会持续执行，直到异步逻辑全部结束。</p><p><strong>普通的dispatch只支持对象类型的参数，redux-thunk这个中间件，添加了函数类型参数的支持，类似的，redux-promise添加了对promise类型参数的支持。</strong></p><h2 id="UI组件和容器组件"><a href="#UI组件和容器组件" class="headerlink" title="UI组件和容器组件"></a>UI组件和容器组件</h2><p>React-Redux将所有组件分为UI组件和容器组件两类。</p><p>UI组件特征：</p><ul><li>只负责UI的呈现，不带有任何业务逻辑。</li><li>没有状态（即不使用this.state这个变量）</li><li>所有参数由this.props提供</li><li>不使用任何Redux的API</li></ul><p>容器组件特征：</p><ul><li>负责管理数据和业务逻辑，不负责UI的呈现</li><li>带有内部状态</li><li>使用Redux的API</li></ul><p>当一个组件既涉及UI呈现，又包含业务逻辑处理，我们可以把它拆分成这样的结构：外面一个容器组件，里面包含一个UI组件，前者负责从外部获取数据传给内部，后者负责根据传来的数据渲染出视图。</p><h4 id="connect（）"><a href="#connect（）" class="headerlink" title="connect（）"></a>connect（）</h4><p>react-redux方法提供connect方法用于从UI组件中生成容器组件。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">export const Home &#x3D; <br>      connect(<br>        mapStateToProps,<br>        mapDispatchToProps)<br>(UIComponent)<br></code></pre></td></tr></table></figure><p>这个方法后面跟两个括号，第一个括号接收两个参数mapStateToProps和mapDispatchToProps。第二个括号传入需要包裹的UI组件。</p><h5 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h5><p>负责输入逻辑，将外部的state映射为内部的props。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">const mapStateToProps &#x3D; (state: RootState, ownProps) &#x3D;&gt; &#123;<br>  return &#123;<br>    loading: state.recommendProducts.loading,<br>    error: state.recommendProducts.error,<br>    productList: state.recommendProducts.productList<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>是一个函数，接收外部的state为参数，返回一个对象，里面的每个键值对就是一个映射，比如说，通过this.props.loading，可以获取到store中state的loading属性。mapStateToProps会订阅store，当state更新时，会自动执行，重新计算UI组件的参数，触发重新渲染。</p><p>如果connect方法省略这个参数，UI组件就不会订阅store，也就是state的更新不会触发UI组件更新。</p><h5 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h5><p>用来建立UI组件参数到store.dispatch方法的映射。它可以是一个函数，也可以是一个对象。</p><p>如果是函数，他会接收dispatch和ownProps作为参数，返回一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs react">const mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;<br>  return &#123;<br>    giveMeData: () &#x3D;&gt; &#123;<br>      dispatch(giveMeDataActionCreator())<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果mapDispatchToProps是对象，它的每一个键值是一个函数，被当作action creator。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs react">const mapDispatchToProps &#x3D; &#123;<br>  giveMeData: () &#x3D;&gt; &#123;<br>    type:...,<br>    payload: ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>connect方法能生成容器组件，但要让容器获取到store中的state，才能生成UI组件的参数。</p><p>一种方便的方法是，使用react-redux提供的Provider组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs react">import &#123; Provider &#125; from &#39;react-redux&#39;<br>&lt;Provider store&#x3D;&#123;store&#125;&gt;<br>&lt;App &#x2F;&gt;<br>&lt;&#x2F;Provider&gt;<br></code></pre></td></tr></table></figure><p>这样的包裹，使得App内所有子组件都可以通过context获取到state。</p><p>参考资料：</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">阮一峰的网络日志——Redux入门教程一/二/三</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React-Router</title>
    <link href="/2021/02/16/%E5%85%B3%E4%BA%8Ereact-router/"/>
    <url>/2021/02/16/%E5%85%B3%E4%BA%8Ereact-router/</url>
    
    <content type="html"><![CDATA[<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs react">React.render((<br>  &lt;Router&gt;<br>    &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;<br>      &lt;Route path&#x3D;&quot;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;<br>      &lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;<br>        &lt;Route path&#x3D;&quot;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;<br>      &lt;&#x2F;Route&gt;<br>    &lt;&#x2F;Route&gt;<br>  &lt;&#x2F;Router&gt;<br>), document.body)<br></code></pre></td></tr></table></figure><p>通过path属性和component属性，可以配置url对应的路由。</p><p>此时，当url为’/‘时，我们会渲染App组件，但这时this.props.children是undefined，这种情况下，我们可以使用IndexRoute设置默认页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs react">React.render((<br>  &lt;Router&gt;<br>    &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;<br>      &lt;IndexRoute component&#x3D;&#123;Dashboard&#125;&#x2F;&gt;<br>      &lt;Route path&#x3D;&quot;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;<br>      &lt;Route path&#x3D;&quot;inbox&quot; component&#x3D;&#123;Inbox&#125;&gt;<br>        &lt;Route path&#x3D;&quot;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;<br>        &#123;&#x2F;* 使用 &#x2F;messages&#x2F;:id 替换 messages&#x2F;:id *&#x2F;&#125;<br>        &#123;&#x2F;*&lt;Route path&#x3D;&quot;&#x2F;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;*&#x2F;&#125;<br>        &#123;&#x2F;*&lt;Redirect from&#x3D;&quot;messages&#x2F;:id&quot; to&#x3D;&quot;&#x2F;messages&#x2F;:id&quot; &#x2F;&gt;*&#x2F;&#125;<br>      &lt;&#x2F;Route&gt;<br>    &lt;&#x2F;Route&gt;<br>  &lt;&#x2F;Router&gt;<br>), document.body)<br></code></pre></td></tr></table></figure><p>如果我们想url为/message/:id也能正常访问，那么只需使用 /messages/:id 替换 messages/:id，但这样做会导致url被改变，当我们访问/inbox/message/:id时，会得到错误的页面。要解决这个问题，我们还要加一个Redirect标签。</p><h2 id="Router中的history属性"><a href="#Router中的history属性" class="headerlink" title="Router中的history属性"></a>Router中的history属性</h2><p>history知道如何监听浏览器地址的变化，并解析这个url转化为location对象，然后router使用它匹配到路由，最后正确渲染组件。</p><ul><li><p><strong>browserHistory</strong></p><p>是使用react router的应用推荐的history，它使用浏览器中的 History API 用于处理 URL，创建一个像<code>example.com/some/path</code>这样真实的 URL。当URL发生变化的时候，会向服务器发送request请求。对多页面模式应用（MPA），浏览器会通过自身的history处理好页面间的操作，但对于单页面应用（SPA），只有一个真实的HTML页面，是无法体现页面跳转效果的，这时，需要服务器配合，模拟出多个HTML页面，从而实现浏览器真实的页面跳转效果。</p></li><li><p><strong>hashHistory</strong></p><p>Hash history 使用 URL 中的 hash（<code>#</code>）部分去创建形如 <code>example.com/#/some/path</code> 的路由。不需要服务器的任何配置就可以运行。</p></li><li><p><strong>createMemoryHistory</strong></p><p>Memory history 不会在地址栏被操作或读取。这就解释了我们是如何实现服务器渲染的。同时它也非常适合测试和其他的渲染环境（像 React Native ）。</p><p>和另外两种history的一点不同是你必须创建它，这种方式便于测试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> history = createMemoryHistory(location)<br></code></pre></td></tr></table></figure><h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2></li></ul><p>react-router实现了路由的核心功能，而react-router-dom则基于react-router，加入了浏览器环境下的一些功能，比如说Link组件、BrowserRouter和HashRouter组件。但类似Switch、Route这样的组件，react-router-dom都是从react-router中引入，然后重新导出而已。因此，我们在npm安装时，不用再显示安装react-router了。</p><h2 id="Switch组件"><a href="#Switch组件" class="headerlink" title="Switch组件"></a>Switch组件</h2><p>会从上往下匹配它包裹的Route中的path，渲染第一个匹配的URL。</p><h2 id="Route组件"><a href="#Route组件" class="headerlink" title="Route组件"></a>Route组件</h2><p>他的path属性总是匹配url的前缀，因此path=’/‘会匹配任何url，因此我们要把这一条route放在switch的最后或者使用exact关键字修饰。</p><h2 id="react-router-dom的hooks"><a href="#react-router-dom的hooks" class="headerlink" title="react-router-dom的hooks"></a>react-router-dom的hooks</h2><h3 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h3><p>获取history实例，通过history.push()方法跳转路由。</p><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><p>返回一个location对象，包含当前url的信息。</p><h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h3><p>返回键值对对象，包含匹配到的路由中的参数。</p><h3 id="useRouteMatch"><a href="#useRouteMatch" class="headerlink" title="useRouteMatch"></a>useRouteMatch</h3><p>和<Route>一样用来匹配当前URL，但是不会渲染对应的组件，只是返回match对象。</p><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>使用这个高阶组件，就可以从props中获取到match，location和history的信息。在外部可以通过WrappedComponent这个静态属性获取到原来的组件。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hook</title>
    <link href="/2021/02/11/React-Hook%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/02/11/React-Hook%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p></blockquote><h2 id="使用Hook的动机"><a href="#使用Hook的动机" class="headerlink" title="使用Hook的动机"></a>使用Hook的动机</h2><ol><li><p><strong>Hook 使你在无需修改组件结构的情况下复用状态逻辑</strong>。在Hook之前，我们可以使用render props和高阶组件来添加可复用的状态逻辑。</p><p><strong>render props</strong>就是在react组件之间使用一个值为函数的prop共享代码技术，组件接收一个返回React元素的函数，并在组件内部调用这个函数完成渲染逻辑。（这个prop的名字叫render或其他名字），而且也不一定要放到JSX元素的attribute列表中，也可以放在元素标签内部。</p><p><strong>高阶组件</strong>（Higher Order Component）是参数为组件，返回值为新组件的函数。HOC将组件包装在容器组件中来组成新的组件，来完成一些可复用的逻辑。</p><p>但这两个方案需要重新组织组件的结构，可能使代码难以理解。使用Hook可以从组件中提取状态逻辑，使这些逻辑可以单独测试且复用，并无需修改组件结构。</p></li><li><p>我们维护组件时，随着时间推移，组建的生命周期函数往往变得臃肿，会有很多不相关的状态逻辑。<strong>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</strong>，而并非强制按照生命周期划分。</p></li><li><p><strong>Hook 使你在非 class 的情况下可以使用更多的 React 特性</strong>。无需理解class</p></li></ol><h2 id="Hook的特性"><a href="#Hook的特性" class="headerlink" title="Hook的特性"></a>Hook的特性</h2><p>Hook是钩子的意思，就是我们使用函数式组件时，尽量写成纯函数，如果需要React state和生命周期等特性的函数，就使用Hook完成这些原本在class中才能实现的需求。Hook是</p><ul><li>完全可选的</li><li>100%向后兼容</li><li>现在可用</li><li>没有计划从React中移除class</li></ul><h2 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a>Hook使用规则</h2><ul><li>只能在函数最外层调用Hook，不要再循环、条件判断或子函数中调用。</li></ul><p>React怎么知道哪个state对应哪个useState，答案是靠Hook执行的顺序，如果我们在条件语句中使用hook，那么很有可能导致前后两次hooks执行顺序发生改变，导致bug产生。如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的内部。</p><ul><li>只能在React的函数式组件中调用，不要在其他JavaScript函数中调用。</li></ul><h2 id="React中几种常见的Hook"><a href="#React中几种常见的Hook" class="headerlink" title="React中几种常见的Hook"></a>React中几种常见的Hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a><strong>useState</strong></h3><p>相当于类组件中的state。</p><p>当我们调用useState时，我们传入一个参数，作为这个state的初始值，它返回一个有两个元素的数组，分别代表当前state的值以及更新这个state的函数，比如<code>[count, setCount] = useState(0)</code>，通过数组解构，我们得到两个变量，count是这个state的变量名，我们可以调用setCount更新count这个state。</p><p>使用useState时，应该使用单个state变量还是使用一个对象打包所有state？</p><p>React官方推荐把 state 切分成多个 state 变量，因为每次更新一个state，会用新值整个替换旧值，不像class组件的setState那样合并。因此如果非要用一个对象包含所有state，state的更新要这样实现：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State] = useState(&#123; left: <span class="hljs-number">0</span>, top: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span> &#125;);<br>...<br>/ 展开 「...<span class="hljs-keyword">state</span>」 以确保我们没有 「丢失」 width 和 height<br>     <span class="hljs-built_in">set</span>State(<span class="hljs-keyword">state</span> =&gt; (&#123; ...<span class="hljs-keyword">state</span>, left: e.pageX, top: e.pageY &#125;));<br></code></pre></td></tr></table></figure><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><strong>useEffect</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">() =&gt;</span> &#123;...&#125;, []);<br></code></pre></td></tr></table></figure><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。我们可以使用useEffect完成在函数式组件中这些功能。</p><p>清除操作：只需在返回值中返回一个函数，那么React会在组件卸载的时候执行清除操作并调用它，比如取消订阅。</p><p>默认情况下，useEffect会在每次渲染后执行，如果要通知React跳过对effect的调用，即不要每次渲染都调用，我们可以传递数组作为第二个参数，比如我们传入[count]作为第二个参数，那么只有当count发生改变时，这个副作用函数才会被执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//相当于componentDidMount和componentWillUnmount</span><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;...&#125;, [])<br><span class="hljs-comment">//会紧紧盯着count，只要count值改变，就会执行</span><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;...&#125;, [count])<br><span class="hljs-comment">//默认情况，相当于componentDidMount和componentDidUpdate</span><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;...&#125;)<br></code></pre></td></tr></table></figure><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a><strong>useContext</strong></h3><p>在组件之间共享状态的钩子。在React中，如果我们要传递变量，可以使用props属性向下传递给子组件。这种方法很简单，但当我们想把变量传递给子组件的子组件时，就需要使用子组件的props再往下传递，这样就形成了props的深度注入。随着props注入越深，组件更新的频率也越来越高，UI效率也就越来越慢。</p><p>而useContext就是来解决非父子组件的数据共享问题的。</p><p>假设说我们需要全局共享一个变量，username。</p><p>第一步，我们要利用React Context API，在组件外部创建一个context，并传入默认初始值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> defaultContextValue = &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;sxx&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> appContext = React.createContext(defaultContextValue)<br></code></pre></td></tr></table></figure><p>然后，为了使App组件和其子组件能共享这个username，我们要用appContext.Provider把整个render函数包裹起来。并且要把defaultContextValue注入到value属性中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;appContext.Provider value=&#123;defaultContextValue&#125;&gt;<br>  &lt;App /&gt;<br>&lt;/appContext.Provider&gt;<br></code></pre></td></tr></table></figure><p>接下来，我们就可以在他的子孙组件中访问到username这个变量了。</p><p>有两种方法：</p><ol><li>利用appContext.Consumer组件，在组件内部使用花括号，使用箭头函数在其内部共享数据：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; appContext &#125; <span class="hljs-keyword">from</span> ...<br>...<br>  &lt;appContext.Consumer&gt;<br>  &#123;<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    &#123;<span class="hljs-comment">/*在这里可以访问到全局的username啦*/</span>&#125;<br>    &lt;h1&gt;&#123;value.username&#125;&lt;/h1&gt;<br>  &#125;&#125;<br>&lt;/appContext.Consumer&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>使用React Hook。利用useContext钩子函数，我们不用改变代码的结构，能很方便的在组件中获取数据：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> value = useContext(appContext);<br><span class="hljs-comment">//接着就可以在return中直接使用value了</span><br></code></pre></td></tr></table></figure><p>useContext这个hook极大的减少了模板代码，降低了代码层级，也消灭了多个consumer嵌套的可能性。</p><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a><strong>useReducer</strong></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);<br></code></pre></td></tr></table></figure><p>这个钩子接收一个reducer和initialState为参数，返回当前状态和dispatch action的函数，可以在不使用redux的情况下，管理数据状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> myReducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">switch</span>(action.type)  &#123;<br>    <span class="hljs-keyword">case</span>(<span class="hljs-string">&#x27;countUp&#x27;</span>):<br>      <span class="hljs-keyword">return</span>  &#123;<br>        ...state,<br>        count: state.count + <span class="hljs-number">1</span><br>      &#125;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span>  state;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//组件代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(myReducer, &#123; <span class="hljs-attr">count</span>:   <span class="hljs-number">0</span> &#125;);<br>  <span class="hljs-keyword">return</span>  (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;countUp&#x27;</span> &#125;)&#125;&gt;<br>        +<span class="hljs-number">1</span><br>      &lt;/button&gt;<br>      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义Hook"><a href="#自定义Hook" class="headerlink" title="自定义Hook"></a><strong>自定义Hook</strong></h3><p>自定义 Hook 的命名以use开头，不需要具有特殊的标识。我们可以自由的决定它的参数是什么，以及它应该返回什么（如果需要的话）。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">React Hook官方文档</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html">阮一峰的网络日志——React Hooks 入门教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode之买卖股票题目总结</title>
    <link href="/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>关于股票买卖的题目，都可以用动态规划来解决，我们要根据具体题目，分析不同的初始条件以及转移方程。在接下来的每一道题目中，我都会提供使用动态规划方法的解答，以及一些针对某道特定的题目，更为简单的解答思路。</p><h2 id="买卖股票的最佳时机Ⅰ"><a href="#买卖股票的最佳时机Ⅰ" class="headerlink" title="买卖股票的最佳时机Ⅰ"></a>买卖股票的最佳时机Ⅰ</h2><p><img src="/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/1.png" alt="题目描述"></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>假设以dp[i]来表示第i天的最大利润，我们以dp[i][0]和dp[i][1]来分别代表今天结束时手上持有股票的状态和不持有状态的股票。<br>对于今天结束时持有股票的状态，有可能是昨天结束时已经持有了股票，今天没有进行任何操作，也有可能是今天以prices[i]的价格买入了股票。因此转移方程为<code>dp[i][0] = Math.max&#123;dp[i-1][0], -prices[i]&#125;</code>。<br>而如果今天结束时不持有股票，那么可能是昨天结束时已经不持有股票了，今天没有进行任何操作，也可能是昨天结束时持有股票，今天以prices[i]的价格卖出。那么转移方程为<code>dp[i][1] = Math.max&#123;dp[i-1][1], dp[i-1][0] + prices[i]&#125;</code>。<br>初始条件：第一天结束若是持有股票，则利润一定是-prices[i],即<code>dp[0][0] = -prices[i]</code>。第一天结束若不持有股票，一定是没有买也没有卖，即<code>dp[i][1] = 0</code>。<br>我们可以观察到，第i天的状态只与第i-1天的状态有关，因此我们想到了空间优化的措施，用两个变量存储前一天两种状态下的最大利润，避免创建二维数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = prices.length;<br>    <span class="hljs-keyword">let</span> buy = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> sell = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br> <span class="hljs-keyword">let</span> s0 = buy, s1 = sell;<br>        buy = <span class="hljs-built_in">Math</span>.max(s0, -prices[i])<br>        sell = <span class="hljs-built_in">Math</span>.max(s1, s0 + prices[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="计算最大的差值"><a href="#计算最大的差值" class="headerlink" title="计算最大的差值"></a>计算最大的差值</h3><p>对这道题来说，动态规划其实有点小题大做了。由于只能进行一次交易，我们只需要知道prices[j] - prices[i] (j&gt;i) 的最大值。用一个minPrice来维护最小买入价格，以profit来记录当前的最大利润，遍历一遍数组，比较得出当前的最大利润以及更新minPrice。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> minPrice = prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;prices.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(prices[i] &lt; minPrice)&#123;<br>            minPrice = prices[i]<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            profit = <span class="hljs-built_in">Math</span>.max(profit, prices[i] - minPrice)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机Ⅱ"><a href="#买卖股票的最佳时机Ⅱ" class="headerlink" title="买卖股票的最佳时机Ⅱ"></a>买卖股票的最佳时机Ⅱ</h2><p><img src="/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/2.png" alt="题目描述"></p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>这道题和第一题的唯一区别是可以进行无限次的交易。如果今天结束的状态是持有股票，那么前一天有可能是完成了一次交易，卖掉了股票。因此dp[i][0]的转移方程就变成了<code>dp[i][0] = Math.max&#123;dp[i-1][0], dp[i-1][1] - prices[i]&#125;</code>（因为初始条件dp[i][1] = 0，所以如果是进行第一次交易，也不会影响结果）。<br>和上一题一样，我们也可以使用两个变量进行空间的优化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = prices.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> buy = -prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> sell = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">let</span> a = buy, b = sell;<br>        buy = <span class="hljs-built_in">Math</span>.max(a, b - prices[i]);<br>        sell = <span class="hljs-built_in">Math</span>.max(b, a + prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>由于交易次数不限，我们可以这样想：加入今天的价格比明天低，那么我们就在今天买入，明天卖出，这也必能增加利润。如果价格连续几天都攀升，我们使用这种方法就相当于在价格最低点买入，最高点卖出。这样我们遍历一次数组就能得到最大利润。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; prices.length)&#123;<br>        <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i-<span class="hljs-number">1</span>])&#123;<br>            profit += prices[i] - prices[i-<span class="hljs-number">1</span>]<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机Ⅲ"><a href="#买卖股票的最佳时机Ⅲ" class="headerlink" title="买卖股票的最佳时机Ⅲ"></a>买卖股票的最佳时机Ⅲ</h2><p><img src="/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/3.png" alt="题目描述"></p><h3 id="动态规划1-0"><a href="#动态规划1-0" class="headerlink" title="动态规划1.0"></a>动态规划1.0</h3><p>在前面题目的基础上，这道题目加了一个限制，最多完成两笔交易，那么一天结束之后，我们可能有五种状态：</p><ol><li>没有过进行任何交易</li><li>持有第一支股票（第一笔交易中）</li><li>完成了第一次交易（买和卖），现在不持有股票</li><li>持有第二支股票（第二笔交易中）</li><li>完成第二次交易（买和卖），现在不持有股票<br>第一个状态，也是初始状态，利润一定为0，因此不必维护与更新。<br>我们用dp[i][0]、dp[i][1]、dp[i][2]、dp[i][3]分别表示第i天2-5状态下的最大利润。用-Infinity来表示不可能的状态(如果第一笔交易没完成或收益不为正，就不进行第二次交易)。那么<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br><span class="hljs-attribute">dp</span>[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-attribute">dp</span>[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = -Infinity<br><span class="hljs-attribute">dp</span>[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = -Infinity<br></code></pre></td></tr></table></figure>接下来考虑每一天的转移方程：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">// 第一笔交易的转移方程不必多说<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, -prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span> + prices<span class="hljs-comment">[i]</span>);<br>// 如果前一天第一笔交易结束时收益不为正，说明第一笔交易没有意义也无效，不应该有第二次交易，<br>// 因此把最大利润设为-Infinity<br>// 如果前一天第一笔交易结束时收益大于0，今天结束的状态是持有第二支股票<br>// 那么有可能是延续了前一天的状态或是昨天卖出第一支股票，今天买入第二支股票<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> &gt; 0 ? Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> - prices<span class="hljs-comment">[i]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span>) : -Infinity<br>// 如果前一天不可能买入第二天股票，那么今天也不可能售出<br>// 如果dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span>有效，那么有可能延续昨天的状态或是在昨天买入的基础上卖出股票<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[3]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span> != -Infinity ? Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[3]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span> + prices<span class="hljs-comment">[i]</span>) : -Infinity<br></code></pre></td></tr></table></figure>最后返回最大利润，有可能没有进行交易、进行一次交易、或进行了两次交易。因此返回这三个的最大值就可以了，也就是<code>Math.max(0, dp[prices.length-1][1], dp[prices.length-1][3])</code><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs inform7">var maxProfit = function(prices) &#123;<br>    let n = prices.length;<br>    if(n == 0) return 0;<br>    let dp = <span class="hljs-comment">[]</span>;<br>    dp<span class="hljs-comment">[0]</span> = <span class="hljs-comment">[]</span>;<br>    dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = -prices<span class="hljs-comment">[0]</span>; <br>    dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = 0;<br>    dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[2]</span> = -Infinity; dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[3]</span> = -Infinity;<br>    for(let i = 1; i &lt; n; i++)&#123;<br>        dp<span class="hljs-comment">[i]</span> = <span class="hljs-comment">[]</span>;<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, -prices<span class="hljs-comment">[i]</span>)<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span> + prices<span class="hljs-comment">[i]</span>);<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[2]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> &gt; 0 ? Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> - prices<span class="hljs-comment">[i]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span>) : -Infinity<br>        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[3]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span> != -Infinity ? Math.max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[3]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[2]</span> + prices<span class="hljs-comment">[i]</span>) : -Infinity<br>    &#125;<br>    return Math.max(0, dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[3]</span>, dp<span class="hljs-comment">[n-1]</span><span class="hljs-comment">[1]</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="动态规划2-0"><a href="#动态规划2-0" class="headerlink" title="动态规划2.0"></a>动态规划2.0</h3>无论题目是否允许同一天买入并卖出，最终答案都不会受到影响，因为这一操作的收益为0。<br>在这一思想基础上，我们考虑对动态规划作优化。<br>我们用<strong>buy1、sell1、buy2、sell2</strong>分别代表2-4状态的最大利润。<br>边界条件（第一天结束时）：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">buy1</span> = -prices[<span class="hljs-number">0</span>] <br><span class="hljs-attr">sell1</span> = <span class="hljs-number">0</span> <br><span class="hljs-attr">buy2</span> = -prices[<span class="hljs-number">0</span>] <br><span class="hljs-attr">sell2</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>接下来考虑转移方程，<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">buy1</span> = Math.max&#123;buy1, -prices[i]&#125;<br><span class="hljs-attr">sell1</span> = Math.max&#123;sell1, buy1 + prices[i]&#125;<br><span class="hljs-attr">buy2</span> = Math.max&#123;buy2, sell1 - prices[i]&#125;<br><span class="hljs-attr">sell2</span> = Math.max&#123;sell2, buy2 + prices[i]&#125;<br></code></pre></td></tr></table></figure>有了前面题目的铺垫，得到这个转移方程并不难，只是这次我们没有用临时变量存储前一天的最大利润，而是直接计算。这样做会对结果有影响吗？答案是不会。比如在计算第i天的sell1的时候，我们用到的变量是第i天的buy1，它多考虑了第i天买入股票的情况，而这对计算sell1（第i天卖出股票）不会有任何影响，因为第i天买入又在第i天卖出，利润为0，对答案不会有影响。同理，计算buy2和sell2时，也可以直接用当天的值来算。<br>最后返回最大利润，必然是sell1、sell2和0之中的最大值，由于sell1和sell2的初始状态就是0，所以不用额外和0作比较。如果最后最好的情况是只进行一次交易，由于我们允许了同一天买和卖，sell1和sell2其实是相等的，因此最终返回的最大利润其实就是sell2。<br>这样，我们就得到了解答：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = prices.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> buy1 = -prices[<span class="hljs-number">0</span>], sell1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> buy2 = -prices[<span class="hljs-number">0</span>], sell2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        buy1 = <span class="hljs-built_in">Math</span>.max(buy1, -prices[i]);<br>        sell1 = <span class="hljs-built_in">Math</span>.max(sell1, buy1 + prices[i]);<br>        buy2 = <span class="hljs-built_in">Math</span>.max(buy2, sell1 - prices[i]);<br>        sell2 = <span class="hljs-built_in">Math</span>.max(sell2, buy2 + prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell2;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机Ⅳ"><a href="#买卖股票的最佳时机Ⅳ" class="headerlink" title="买卖股票的最佳时机Ⅳ"></a>买卖股票的最佳时机Ⅳ</h2><img src="/2021/02/08/Leetcode%E4%B9%8B%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/4.png" alt="题目描述"><br>上一题最多允许2次交易，我们用4的变量来记录不同状态的最大利润。这道题目最大能进行k次交易，那么就一共会有2k个状态，因此，我们可以考虑用两个数量为k的数组表示第k次交易买和卖情况下的最大利润。初始状态和转移方程和上一题差不多。直接上代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = prices.length;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//分别用一个数组记录第k次买入或卖出状态的最大利润</span><br>    <span class="hljs-comment">//初始状态：buy[1] = ... = buy[k] = -prices[0] sell[1] = ... = sell[k] = 0</span><br>    <span class="hljs-comment">//假设允许当天即买即卖，那样子利润为0，对结果不会有影响</span><br>    <span class="hljs-keyword">let</span> buy = [], sell = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= k; i++)&#123;<br>        buy[i] = -prices[<span class="hljs-number">0</span>];<br>        sell[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> d = <span class="hljs-number">1</span>; d &lt; n; d++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)&#123;<br>            buy[i] = <span class="hljs-built_in">Math</span>.max(buy[i], sell[i-<span class="hljs-number">1</span>] - prices[d])<br>            sell[i] = <span class="hljs-built_in">Math</span>.max(sell[i], buy[i] + prices[d])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sell[k];<br>&#125;;<br></code></pre></td></tr></table></figure>到这，我们就由易而难的解决了买卖股票的最佳时机四道题。他们都可以用动态规划解决，只是我们要根据具体的题目条件确定边界值和转移方程。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>动态规划</tag>
      
      <tag>买卖股票</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>better-scroll的踩坑总结</title>
    <link href="/2021/02/08/better-scroll%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/02/08/better-scroll%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="better-scroll是什么"><a href="#better-scroll是什么" class="headerlink" title="better-scroll是什么"></a>better-scroll是什么</h3><p><a href="https://github.com/ustbhuangyi/better-scroll">BetterScroll</a> 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。</p><h3 id="vue中better-scroll的简单使用"><a href="#vue中better-scroll的简单使用" class="headerlink" title="vue中better-scroll的简单使用"></a>vue中better-scroll的简单使用</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这里可以放一些其它的 DOM，但不会影响滚动 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用better-scroll，首先一定要有三层的html元素，最外层是wrapper，要有固定的高度，而且要设置<code> overflow: hidden</code>样式。<br><br/><strong>为什么需要中间的一层content，而不直接用wrapper包含所有&lt;li&gt;标签呢？</strong><br/><br>因为better-scroll默认处理第一个子元素的滚动，而忽略其他子元素，因此我们需要content这一层来包裹真正滚动的元素。<br>使用之前，我们要先通过npm install一下better-scroll，然后再import进来：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Bscroll <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;better-scroll&#x27;</span><br>export <span class="hljs-keyword">default</span> &#123;<br>mounted () &#123;<br>      this.scroll = <span class="hljs-built_in">new</span> Bscroll(this.$refs.<span class="hljs-keyword">wrapper</span>, &#123;<br>        click: <span class="hljs-keyword">true</span><br>      &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过this.$ref取到wrapper这个dom进行初始化，构造函数的第二个是参数是配置项。由于我们使用better-scroll滚动元素默认是不可点击的，因此可以通过设置click为true派发点击事件。<br><br/><br>另外,better-scroll也提供一个方法scrollToElement，通过这个方法，可以将页面滚动到指定的子元素：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.scrollToElement(<span class="hljs-keyword">this</span>.$ref.child)<br></code></pre></td></tr></table></figure><h3 id="踩坑总结"><a href="#踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h3><h4 id="初始化Bscroll之后页面无法滚动"><a href="#初始化Bscroll之后页面无法滚动" class="headerlink" title="初始化Bscroll之后页面无法滚动"></a>初始化Bscroll之后页面无法滚动</h4><p>首先，我们要知道better-scroll的滚动原理，如下图，只有当content的高度大于wrapper的高度，页面才能够滚动。<br><img src="/2021/02/08/better-scroll%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/%E5%8E%9F%E7%90%86%E5%9B%BE.png"><br/><br>但在项目开发过程中，我发现，我的content的高度确实大于wrapper的高度时，页面依然无法滚动，这是为什么？其实原因很有可能是new scroll的时机不对，导致初始化时，wrapper的高度大于content。而我们看到的content高度大于wrapper，其实是在bscroll初始化结束后的因为获取到数据或其他方式改变的。因此，我们初始化Bscroll的时机很重要。<br><br/><br>在很多实际应用中，我们列表的数据往往是动态获取的。而由数据改变到触发页面重新渲染又是一个异步的过程，我们要在获取到数据，并且页面已经重新渲染过后，再进行Bscroll的初始化。</p><blockquote><p>官方文档描述：<br/><br>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。<br>因此，我们可以在数据变化后立即使用nextTick函数，在下一个事件循环中，即dom更新后，再new Bsroll。</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">created () &#123;<br>requestData().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.data = res.data<br>        <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.scroll = <span class="hljs-keyword">new</span> Bscroll(<span class="hljs-built_in">this</span>.$refs.wrapper)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="scroll-refresh"><a href="#scroll-refresh" class="headerlink" title="scroll.refresh()"></a>scroll.refresh()</h4><p>由于数据是可能不断变化的，我们不可能每次数据变更都初始化一个Bscroll，这时，我们可以使用better-scroll提供的另一个方法refresh(),触发重新计算wrapper和content的高度，比如在updated钩子函数或监听某个数据的函数中使用。<br><br/></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//父组件部分代码</span><br>&lt;template&gt;<br>    &lt;div&gt;<br>        ...<br>        &lt;city-list :cities=<span class="hljs-string">&quot;cities&quot;</span>&gt;&lt;/city-list&gt;<br>        ...<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>export default &#123;<br>  name: <span class="hljs-string">&#x27;City&#x27;</span>,<br>  <span class="hljs-keyword">data</span> () &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>      cities: &#123;&#125;<br>        &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    getCityInfo () &#123;<br>      axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/api/city.json&#x27;</span>).then(<span class="hljs-keyword">this</span>.getCityInfoSucc)<br>    &#125;,<br>    getCityInfoSucc (res) &#123;<br>      res = res.<span class="hljs-keyword">data</span><br>      <span class="hljs-keyword">if</span> (res.ret &amp;&amp; res.<span class="hljs-keyword">data</span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = res.<span class="hljs-keyword">data</span><br>        <span class="hljs-keyword">this</span>.cities = <span class="hljs-keyword">data</span>.cities<br>        <span class="hljs-keyword">this</span>.hotCities = <span class="hljs-keyword">data</span>.hotCities<br>      &#125;<br>    &#125;,<br>  &#125;,<br>  created () &#123;<br>    <span class="hljs-keyword">this</span>.getCityInfo()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//子组件部分代码</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;list&quot;</span> ref=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<br>    ...<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :ref=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title border-topbottom&quot;</span>&gt;&#123;&#123;key&#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;<br>                &lt;<span class="hljs-keyword">div</span><br>                    <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item border-bottom&quot;</span><br>                    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>                    :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>                    @click=<span class="hljs-string">&quot;handleCityClick(innerItem.name)&quot;</span><br>                &gt;<br>                    &#123;&#123;innerItem.name&#125;&#125;<br>                &lt;/<span class="hljs-keyword">div</span>&gt;<br>            &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&#x27;CityList&#x27;</span>,<br>  props: &#123;<br>    cities: Object<br>  &#125;,<br>  methods: &#123;<br>    mounted () &#123;<br>      <span class="hljs-keyword">this</span>.scroll = <span class="hljs-keyword">new</span> Bscroll(<span class="hljs-keyword">this</span>.$refs.wrapper, &#123;<br>        click: <span class="hljs-keyword">true</span><br>      &#125;)<br>    &#125;,<br>    updated () &#123;<br>      <span class="hljs-keyword">this</span>.scroll.refresh()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是我开发项目中的部分代码,其中，父组件在created后通过axios请求数据，以props的形式传值给子组件，子组件要根据这个值渲染列表，也就是说，子组件里用到了Bscroll，但数据和dom结构依赖于父组件传过来的值而动态更新。<br/><br>在这里，我没法在数据获取成功的回调函数中使用nextTick，因此我想到一个办法，在updated钩子函数中，使用refresh函数，当父组件获取数据成功后，props中的值也会相应update，此时让scroll重新计算dom元素的高度，列表便能正常滚动了。<br/><br>当然，如果担心数据频繁变化，导致refresh刷新频繁，影响性能的话，可以利用timer进行防抖操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//data里定义一个timer</span><br>updated () &#123;<br>  <span class="hljs-keyword">const</span> refresh=<span class="hljs-built_in">this</span>.debounce(<span class="hljs-number">500</span>)<br>  refresh()<br>&#125;,<br>methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">debounce</span>(<span class="hljs-params">delay</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> timer1 = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (timer1) <span class="hljs-built_in">clearTimeout</span>(timer1)<br>      timer1 = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.scroll.refresh()<br>      &#125;, delay)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="better-scroll和scrollBehavior"><a href="#better-scroll和scrollBehavior" class="headerlink" title="better-scroll和scrollBehavior"></a>better-scroll和scrollBehavior</h4><p>在项目中，我想让每次进入这个页面时，列表都回到顶端，因此我利用vue-router的scrollBehavior：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">scrollBehavior (<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>, savedPosition) &#123;<br>  <span class="hljs-keyword">if</span> (savedPosition) &#123;<br><span class="hljs-built_in">    return</span> savedPosition<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">    return</span> &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这在better-scroll列表页中并没有没有生效，但是重新进入其他页面都能回到顶端，这又是为什么呢？<br><br/><br>我们要搞清楚这两个scroll的原理。当使用vue-router时，scrollBehavior记录的是整个页面的滚动，也就是说，页面是由于内容太多，自动撑高的，这个高度不固定。而使用better-scroll（再次引用上面那张图），外层wrapper的高度是固定下来的，滚动的是wrapper内的元素，因此，整个页面其实是没有滚动的，这样就造成了列表里面的元素还停留在原来的位置，但页面其实已经回到顶端的现象。<br><img src="/2021/02/08/better-scroll%E7%9A%84%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/%E5%8E%9F%E7%90%86%E5%9B%BE.png"><br/><br>那要怎么让better-scroll内滚动的元素回到最顶端呢？<br>可以利用scrollToElement(this.$refs.wrapper)方法，或者scrollTo(0, 0)方法。</p><p>以上是我自己在使用better-scroll时的一些体验与心得，如有不当，欢迎指出。</p><p>参考：<br/><br><a href="https://zhuanlan.zhihu.com/p/27407024">当 better-scroll 遇见 Vue</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue的父子组件的生命周期顺序</title>
    <link href="/2021/02/08/Vue%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F/"/>
    <url>/2021/02/08/Vue%E7%9A%84%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，vue实例的生命周期依次是：</p><pre><code>beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted -&gt; ( beforeUpdate -&gt; updated ) -&gt; beforeDestroy -&gt; destroyed</code></pre><p>但当我们使用组件时，父组件和子组件的生命周期钩子的执行顺序又是怎样的呢？我们将通过代码验证：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在父组件中使用子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>   &#123;&#123;msg&#125;&#125;<br>   <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;fromParent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br>Vue.component(<span class="hljs-string">&#x27;child&#x27;</span>, &#123;<br>    template:<span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div&gt;&#123;&#123;msg&#125;&#125;, I got &#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="hljs-string">    `</span>,<br>    props: [<span class="hljs-string">&#x27;message&#x27;</span>],<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span>&#123;<br>            msg: <span class="hljs-string">&#x27;我是子组件&#x27;</span><br>        &#125;<br>    &#125;,<br>    beforeCreate () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child before create&#x27;</span>)<br>    &#125;,<br>    created () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child created&#x27;</span>)<br>    &#125;,<br>    beforeMount () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child before mount&#x27;</span>)<br>    &#125;,<br>    mounted () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child mounted&#x27;</span>)<br>    &#125;,<br>    beforeDestroy () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child before destroy&#x27;</span>)<br>    &#125;,<br>    destroyed () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child destroyed&#x27;</span>)<br>    &#125;，<br>    beforeUpdate () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child before update&#x27;</span>)<br>    &#125;,<br>    updated () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child updated&#x27;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//根实例（父组件）</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>    el: <span class="hljs-string">&#x27;#root&#x27;</span>,<br>    data: &#123;<br>        msg: <span class="hljs-string">&#x27;我是父组件&#x27;</span><br>    &#125;,<br>    beforeCreate () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent before created&#x27;</span>)<br>    &#125;,<br>    created () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent created&#x27;</span>)<br>    &#125;,<br>    beforeMount () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent before mount&#x27;</span>)<br>    &#125;,<br>    mounted () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent mounted&#x27;</span>)<br>    &#125;,<br>    beforeDestroy () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent before destroy&#x27;</span>)<br>    &#125;,<br>    destroyed () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent destroyed&#x27;</span>)<br>    &#125;，<br>    beforeUpdate () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent before update&#x27;</span>)<br>    &#125;,<br>    updated () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent updated&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>  <strong>运行结果如下图：</strong>  </p>  <div align='center'>      <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a3c8e02a1fd4a4abf1129950a7b99f8~tplv-k3u1fbpfcp-watermark.image">    </div>  <div align=center>加载渲染</div>   <br/>  <div align='center'>      <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93685ff41f6041f4998692def0e8aead~tplv-k3u1fbpfcp-watermark.image">    </div>    <div align=center>组件销毁</div>  <br/>  <div align='center'>      <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7aff5f07c14a159f961da598029d8f~tplv-k3u1fbpfcp-watermark.image">    </div>   <div align=center>父组件数据更新</div>  <br/>  <div align='center'>      <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a19860f81ec43d7be454f6c3c35e1cd~tplv-k3u1fbpfcp-watermark.image">    </div>   <div align=center>子组件数据更新（单向数据流）</div>    由此我们得知，父子组件的生命周期函数是嵌套的关系，**从外到内，再从内到外**]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵中的最长递归路径</title>
    <link href="/2021/02/08/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%BD%92%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/02/08/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%BD%92%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述（leetcode329题）"><a href="#题目描述（leetcode329题）" class="headerlink" title="题目描述（leetcode329题）"></a>题目描述（leetcode329题）</h2><p><img src="/2021/02/08/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%BD%92%E8%B7%AF%E5%BE%84/%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0.png" alt="题目描述"></p><h2 id="基于深度优先搜索"><a href="#基于深度优先搜索" class="headerlink" title="基于深度优先搜索"></a>基于深度优先搜索</h2><p>我们可以把矩阵每个单元格看作一个点，而若一个点的值小于相邻点的值，那么就看作这两个点之间有一条有向边，由小的点指向大的点。这样，求最长递增路径的问题，就变成了求有向无环图最长路径的问题。我们可以用深度优先搜索来解决。</p><p>那么问题又来了，如果直接使用深度优先搜索，那么将会大量重复计算一些节点的路径，因此我们采用记忆化的方法，用一个矩阵记录下已经算好的节点，若这个矩阵的节点值为0，则是没有计算过的，需要计算，否则，直接用它的值就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">matrix</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> longestIncreasingPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> m = matrix.length; <span class="hljs-keyword">var</span> n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">var</span> path = [];<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> dfs = <span class="hljs-function">(<span class="hljs-params">i, j</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(path[i][j] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> path[i][j];<br>        <span class="hljs-keyword">let</span> distance = <span class="hljs-number">0</span>;<br>         <span class="hljs-comment">//可以往上走</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i-<span class="hljs-number">1</span>][j])&#123;<br>            distance = <span class="hljs-built_in">Math</span>.max(dfs(i-<span class="hljs-number">1</span>,j),distance);<br>        &#125;<br>        <span class="hljs-comment">//可以往下走</span><br>        <span class="hljs-keyword">if</span>(i&lt;m-<span class="hljs-number">1</span> &amp;&amp; matrix[i][j] &lt; matrix[i+<span class="hljs-number">1</span>][j])&#123;<br>            distance = <span class="hljs-built_in">Math</span>.max(dfs(i+<span class="hljs-number">1</span>,j),distance);<br>        &#125;<br>        <span class="hljs-comment">//可以往左走</span><br>        <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; matrix[i][j] &lt; matrix[i][j-<span class="hljs-number">1</span>])&#123;<br>            distance = <span class="hljs-built_in">Math</span>.max(dfs(i,j-<span class="hljs-number">1</span>),distance);<br>        &#125;<br>        <span class="hljs-comment">//可以往右走</span><br>        <span class="hljs-keyword">if</span>(j&lt;n-<span class="hljs-number">1</span> &amp;&amp; matrix[i][j] &lt; matrix[i][j+<span class="hljs-number">1</span>])&#123;<br>            distance = <span class="hljs-built_in">Math</span>.max(dfs(i,j+<span class="hljs-number">1</span>),distance);<br>        &#125;<br>        path[i][j] = <span class="hljs-number">1</span> + distance;<br>        <span class="hljs-keyword">return</span> path[i][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        path[i] = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            path[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            res = <span class="hljs-built_in">Math</span>.max(dfs(i,j), res);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(mn) (深度优先搜索的时间复杂度为O(V+E),这里V=mn，E=4mn)</p><p>空间复杂度：O(mn)</p><h2 id="基于拓扑排序（动态规划）"><a href="#基于拓扑排序（动态规划）" class="headerlink" title="基于拓扑排序（动态规划）"></a>基于拓扑排序（动态规划）</h2><p>其实我一开始也有用动态规划解决问题的想法，用一个矩阵记录以该节点为起点最多能沿着递增路径走多远。</p><p>递推公式： <code>dp[i][j] = 1 + max(dp[x][y]) (x，y为i，j相邻的比i，j大的点)</code></p><p>然后通过不断更新dp矩阵，直到矩阵不变，矩阵中最大的值便是最长路径的长度。但是最坏情况下，可能要计算m+n-1次。从时间复杂度上说，是绝对不可取的。而官方题解，则给出了一个更加优雅的解法。</p><p>首先，计算所有节点的出度（从该节点能走到相邻的节点，则出度+1）。出度为0的，则一定是路径的终点，我们把它加进队列里面去。利用基于广度优先搜索的思路，不断更新出度矩阵：本轮中，对于队列里的每一个顶点v，如果其相邻的点u有一条到v的边，那么u的出度-1。这时，如果u的出度变为0，也就意味着u除了能通往v，不能再通向其他节点了。把u也加进队列里，等待下一轮的计算。在这里，我们计算了多少轮，其实也就代表着最长路径的长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longestIncreasingPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> direction = [[<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">var</span> m = matrix.length; <span class="hljs-keyword">var</span> n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">var</span> outDegree = [];<br>    <span class="hljs-keyword">var</span> queue = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        outDegree[i] = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            outDegree[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> direction)&#123;<br>                <span class="hljs-keyword">let</span> row = i + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">let</span> col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;=<span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; matrix[i][j] &lt; matrix[row][col])&#123;<br>                    outDegree[i][j]++<br>                &#125;<br>                <br>            &#125;<br>            <span class="hljs-keyword">if</span>(outDegree[i][j] == <span class="hljs-number">0</span>)&#123;<br>                queue.push([i,j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(queue.length != <span class="hljs-number">0</span>)&#123;<br>        res++;<br>        <span class="hljs-keyword">let</span> len = queue.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> l=<span class="hljs-number">0</span>;l&lt;len;l++)&#123;<br>            <span class="hljs-keyword">let</span> cur = queue.shift();<br>            <span class="hljs-keyword">let</span> i = cur[<span class="hljs-number">0</span>]; <span class="hljs-keyword">let</span> j = cur[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> dir <span class="hljs-keyword">of</span> direction)&#123;<br>                <span class="hljs-keyword">let</span> row = i + dir[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">let</span> col = j + dir[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;=<span class="hljs-number">0</span> &amp;&amp; col &lt; n &amp;&amp; matrix[row][col] &lt; matrix[i][j])&#123;<br>                    outDegree[row][col]--;<br>                    <span class="hljs-keyword">if</span>(outDegree[row][col] == <span class="hljs-number">0</span>)&#123;<br>                        queue.push([row,col]);<br>                    &#125;<br>                &#125;<br>                <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个解法中，用direction数组来计算相邻点坐标，再验证其有效性，相比第一种解法的四个if判断，更加的高效。</p><p>时间复杂度：O(mn)</p><p>空间复杂度：O(mn)</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的第k个最大元素</title>
    <link href="/2021/02/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2021/02/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/02/08/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/Leetcode251.png" alt="题目描述"></p><h3 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h3><p>看到这个题目，找第k个大的元素，第一想法是堆排序！把数组按照堆排序的方式排列，然后进行k次移除最大的元素操作，就能得到结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> arr;<br><span class="hljs-keyword">var</span> size;<br><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-comment">//buildHeap</span><br>    <span class="hljs-keyword">var</span> result;<br>    arr = nums;<br>    size = arr.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-built_in">Math</span>.floor(size/<span class="hljs-number">2</span>)- <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        siftdown(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        result = removeMax();<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">siftdown</span>(<span class="hljs-params">i</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-built_in">Math</span>.floor(size/<span class="hljs-number">2</span>)- <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> child = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(child &lt; size-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(arr[child] &lt; arr[child+<span class="hljs-number">1</span>])<br>            child++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr[child] &gt; arr[i])&#123;<br>        swap(child,i);<br>        siftdown(child);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">i,j</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;v<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeMax</span>(<span class="hljs-params"></span>)</span>&#123;<br>    swap(<span class="hljs-number">0</span>,size-<span class="hljs-number">1</span>);<br>    size--;<br>    siftdown(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> arr[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>确实，这个思路能通过。 时间复杂度应该是O（n + klogn）=O（nlogn），空间复杂度是O（logn）。堆排序也确实是个不错的方法，但用堆排序有没有更优雅的方式呢？<br>当然是有的！<br>我们可以建一个大小为k的最小堆，来记录数组最大的k个元素。通过扫描数组一遍，不断更新调整这个最小堆，最后堆顶的元素，就是我们要求的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> heap = nums.slice(<span class="hljs-number">0</span>,k);<br>    <span class="hljs-keyword">var</span> siftdown = <span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-built_in">Math</span>.floor(k/<span class="hljs-number">2</span>)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">let</span> child = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(child &lt; heap.length-<span class="hljs-number">1</span> &amp;&amp; heap[child+<span class="hljs-number">1</span>] &lt; heap[child])&#123;<br>            child++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(heap[child] &lt; heap[i])&#123;<br>            swap(heap,i,child);<br>            siftdown(child);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-built_in">Math</span>.floor(k/<span class="hljs-number">2</span>);i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        siftdown(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=k;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &gt; heap[<span class="hljs-number">0</span>])&#123;<br>            heap[<span class="hljs-number">0</span>] = nums[i];<br>            siftdown(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>];<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, i, j</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> temp = nums[j];<br>    nums[j] = nums[i];<br>    nums[i] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法对比起对整个数组进行堆排序，用的堆空间更小了，空间复杂度是O（k），时间复杂度是O（nlogk）。</p><h3 id="基于快速排序的思路"><a href="#基于快速排序的思路" class="headerlink" title="基于快速排序的思路"></a>基于快速排序的思路</h3><p>除了利用堆的思路，我们还可以基于快速排序来减治。<br>随机选取一个轴值，通过一轮快速排序的交换，获取到这个轴值的位置，如果刚好是nums.length - k，我们就找到了第k大的元素，这是最好的情况。当然，如果是一般情况，我们也减小了问题的规模。<br>我们令目标值target = nums.length - k,若轴值的位置p&lt;target,我们进一步在p的右边寻找第k大的元素；否则，我们在p的左边寻找。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, k</span>) </span>&#123;<br>   <span class="hljs-keyword">let</span> target = nums.length - k;<br>   <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">let</span> right = nums.length - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>       <span class="hljs-keyword">let</span> p = partition(nums,left,right);<br>       <span class="hljs-keyword">if</span>(p === target) <span class="hljs-keyword">return</span> nums[p];<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p &lt; target) left = p + <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">else</span> right = p - <span class="hljs-number">1</span>;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">nums, left, right</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> p = nums[left];<br>    <span class="hljs-keyword">let</span> j = left;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = left+<span class="hljs-number">1</span>;i&lt;=right;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt; p)&#123;<br>            j++;<br>            swap(nums,j,i);<br>        &#125;<br>    &#125;<br>    swap(nums,left,j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums,i,j</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O（n），空间复杂度：O（1）</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>堆</tag>
      
      <tag>快速排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
